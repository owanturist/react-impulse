---
title: Using Signals in React Components
description: Common patterns for integrating signals with React components
---

This guide covers practical patterns for using signals in React components with the `@owanturist/signal-react` package.

## Reading a Single Signal

Use `useComputed` with a signal directly to read its value:

```tsx
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"

const count = Signal(0)

function Counter() {
  const value = useComputed(count)

  return <div>Count: {value}</div>
}
```

## Reading Multiple Signals

Combine multiple signals in a single `useComputed` call:

```tsx
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"

const firstName = Signal("John")
const lastName = Signal("Doe")

function FullName() {
  const fullName = useComputed((monitor) => {
    return `${firstName.read(monitor)} ${lastName.read(monitor)}`
  }, [])

  return <div>{fullName}</div>
}
```

The empty dependency array `[]` tells React the compute function doesn't depend on any React state or props.

## Using Signals with React Props

When your compute function depends on props, include them in the dependency array:

```tsx
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"

const items = Signal<string[]>([])

function FilteredList({ filter }: { filter: string }) {
  const filtered = useComputed(
    (monitor) => {
      return items.read(monitor).filter((item) => item.includes(filter))
    },
    [filter],
  )

  return (
    <ul>
      {filtered.map((item) => (
        <li key={item}>{item}</li>
      ))}
    </ul>
  )
}
```

## Optimizing Re-renders with Custom Equality

Prevent unnecessary re-renders when signal values are structurally equal:

```tsx
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"

interface Position {
  x: number
  y: number
}

const position = Signal<Position>({ x: 0, y: 0 })

function Cursor() {
  const pos = useComputed((monitor) => position.read(monitor), [], {
    equals: (a, b) => a.x === b.x && a.y === b.y,
  })

  return (
    <div
      style={{
        position: "absolute",
        left: pos.x,
        top: pos.y,
      }}
    />
  )
}
```

## Sharing Signals Between Components

Define signals outside components to share state:

```tsx
import { Signal, batch } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"

// Shared state
const user = Signal<User | null>(null)
const isLoggedIn = Signal((monitor) => user.read(monitor) !== null)

interface User {
  id: string
  name: string
}

function UserProfile() {
  const currentUser = useComputed(user)

  if (!currentUser) {
    return <div>Please log in</div>
  }

  return <div>Welcome, {currentUser.name}!</div>
}

function LoginStatus() {
  const loggedIn = useComputed(isLoggedIn)

  return <div>{loggedIn ? "Logged in" : "Logged out"}</div>
}

function LoginButton() {
  return (
    <button
      onClick={() => {
        user.write({ id: "1", name: "Alice" })
      }}
    >
      Log In
    </button>
  )
}
```

## Building Custom Hooks with useMonitor

Use `useMonitor` for advanced scenarios where you need direct access to the Monitor:

```tsx
import { Signal, type Monitor } from "@owanturist/signal"
import { useMonitor } from "@owanturist/signal-react"
import { useSyncExternalStore } from "react"

const count = Signal(0)

// Custom hook that tracks signal reads
function useSignalSnapshot<T>(read: (monitor: Monitor) => T): T {
  const monitor = useMonitor()
  return read(monitor)
}

function Counter() {
  const value = useSignalSnapshot((monitor) => count.read(monitor))

  return <div>Count: {value}</div>
}
```

## Handling Dynamic Signal Lists

Work with dynamic collections of signals:

```tsx
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"

interface Todo {
  id: string
  text: string
  completed: Signal<boolean>
}

const todos = Signal<Todo[]>([])

function TodoList() {
  const items = useComputed(todos)

  return (
    <ul>
      {items.map((todo) => (
        <TodoItem key={todo.id} todo={todo} />
      ))}
    </ul>
  )
}

function TodoItem({ todo }: { todo: Todo }) {
  const completed = useComputed(todo.completed)

  return (
    <li style={{ textDecoration: completed ? "line-through" : "none" }}>
      {todo.text}
      <button onClick={() => todo.completed.write((c) => !c)}>Toggle</button>
    </li>
  )
}
```

## Avoiding Common Mistakes

### Creating Signals Inside Components

Avoid creating signals inside components without memoization:

```tsx
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"
import { useMemo } from "react"

// Bad: Creates new signal on every render
function BadCounter() {
  const count = Signal(0) // New signal every render!
  const value = useComputed(count)
  return <div>{value}</div>
}

// Good: Create signals outside components
const count = Signal(0)

function GoodCounter() {
  const value = useComputed(count)
  return <div>{value}</div>
}

// Also good: Memoize if signal must be component-scoped
function AlsoGoodCounter() {
  const count = useMemo(() => Signal(0), [])
  const value = useComputed(count)
  return <div>{value}</div>
}
```

### Missing Dependency Arrays

Always provide a dependency array when your compute function is stable:

```tsx
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"

const data = Signal<string[]>([])

// Bad: Compute function recreated every render
function BadComponent() {
  const items = useComputed((monitor) => data.read(monitor))
  return <div>{items.length}</div>
}

// Good: Stable compute function with empty deps
function GoodComponent() {
  const items = useComputed((monitor) => data.read(monitor), [])
  return <div>{items.length}</div>
}
```

## See Also

- [useComputed API](/docs/api/use-computed) - Complete API reference
- [useMonitor API](/docs/api/use-monitor) - Advanced monitor access
- [React Integration Concepts](/docs/concepts/react-integration) - How signals work with React
- [Batching Updates](/docs/guides/batching) - Preventing multiple re-renders
