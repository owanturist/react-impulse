---
title: Resource Cleanup
description: Properly cleaning up resources in effects to prevent memory leaks
---

This guide covers patterns for cleaning up resources like timers, event listeners, and subscriptions in effects.

## Returning Cleanup Functions

Effects can return a cleanup function that runs before re-execution and when the effect stops:

```ts
import { Signal, effect } from "@owanturist/signal"

const userId = Signal("user-1")

effect((monitor) => {
  const id = userId.read(monitor)
  const subscription = subscribeToUser(id)

  // Cleanup runs:
  // 1. Before re-running (when userId changes)
  // 2. When the effect is stopped
  return () => {
    subscription.unsubscribe()
  }
})

function subscribeToUser(id: string) {
  return {
    unsubscribe: () => console.log(`Unsubscribed from ${id}`),
  }
}
```

## Cleaning Up Timers

Always clear intervals and timeouts when dependencies change or the effect stops:

```ts
import { Signal, effect } from "@owanturist/signal"

const isActive = Signal(true)

effect((monitor) => {
  if (!isActive.read(monitor)) {
    return
  }

  const interval = setInterval(() => {
    console.log("Tick")
  }, 1000)

  return () => clearInterval(interval)
})

// When isActive becomes false, cleanup runs and stops the interval
isActive.write(false)
```

For timeouts:

```ts
import { Signal, effect } from "@owanturist/signal"

interface Config {
  delay: number
}

const config = Signal<Config>({ delay: 1000 })

effect((monitor) => {
  const { delay } = config.read(monitor)

  const timer = setTimeout(() => {
    console.log("Timer fired")
  }, delay)

  return () => clearTimeout(timer)
})
```

## Cleaning Up Event Listeners

Remove event listeners when the handler changes or the effect stops:

```ts
import { Signal, effect } from "@owanturist/signal"

const handler = Signal<(e: KeyboardEvent) => void>(() => {})

effect((monitor) => {
  const fn = handler.read(monitor)
  window.addEventListener("keydown", fn)

  return () => window.removeEventListener("keydown", fn)
})
```

## Cleaning Up WebSocket Connections

Close connections when URLs change or the effect stops:

```ts
import { Signal, effect } from "@owanturist/signal"

const wsUrl = Signal("wss://example.com/socket")

effect((monitor) => {
  const url = wsUrl.read(monitor)
  const ws = new WebSocket(url)

  ws.onmessage = (event) => {
    handleMessage(event.data)
  }

  return () => {
    ws.close()
  }
})

function handleMessage(data: unknown) {
  console.log("Received:", data)
}
```

## Cleaning Up External Subscriptions

Unsubscribe from external data sources:

```ts
import { Signal, effect } from "@owanturist/signal"

const userId = Signal("user-123")

effect((monitor) => {
  const id = userId.read(monitor)

  const unsubscribe = database.subscribe(`users/${id}`, (user) => {
    console.log("User updated:", user)
  })

  return unsubscribe
})

// Mock database with subscribe functionality
const database = {
  subscribe: (path: string, callback: (data: unknown) => void) => {
    console.log(`Subscribed to ${path}`)
    return () => console.log(`Unsubscribed from ${path}`)
  },
}
```

## Cleanup Timing

The cleanup function runs at two specific times:

1. **Before re-execution** - When a dependency changes and the effect is about to re-run
2. **On disposal** - When `stop(){:ts}` is called on the effect

```ts
import { Signal, effect } from "@owanturist/signal"

const source = Signal("initial")

const stop = effect((monitor) => {
  const value = source.read(monitor)
  console.log("setup:", value)

  return () => {
    console.log("cleanup:", value)
  }
})
// Logs: "setup: initial"

source.write("updated")
// Logs: "cleanup: initial"
// Logs: "setup: updated"

stop()
// Logs: "cleanup: updated"
```

## Handling Multiple Resources

When an effect creates multiple resources, clean them all up:

```ts
import { Signal, effect } from "@owanturist/signal"

interface Config {
  pollInterval: number
  wsUrl: string
}

const config = Signal<Config>({ pollInterval: 5000, wsUrl: "wss://example.com" })

effect((monitor) => {
  const { pollInterval, wsUrl } = config.read(monitor)

  // Resource 1: Polling interval
  const interval = setInterval(() => {
    console.log("Polling...")
  }, pollInterval)

  // Resource 2: WebSocket
  const ws = new WebSocket(wsUrl)

  // Clean up both resources
  return () => {
    clearInterval(interval)
    ws.close()
  }
})
```

## Conditional Resource Creation

Only create resources when conditions are met:

```ts
import { Signal, effect } from "@owanturist/signal"

const isEnabled = Signal(false)
const intervalMs = Signal(1000)

effect((monitor) => {
  if (!isEnabled.read(monitor)) {
    return // No cleanup needed - no resources created
  }

  const ms = intervalMs.read(monitor)
  const interval = setInterval(() => {
    console.log("Running")
  }, ms)

  return () => clearInterval(interval)
})
```

## See Also

<Cards>
  <Card title="Fundamentals" description="Core signal concepts" href="/docs/concepts/fundamentals" />
  <Card title="effect API" description="Complete API reference" href="/docs/api/effect" />
  <Card title="Optimization" description="Performance techniques" href="/docs/guides/optimization" />
</Cards>
