---
title: Comparison
description: How @owanturist/signal compares to Redux, Zustand, Jotai, and XState for React state management
---

Every React state management library makes trade-offs between bundle size, API surface, re-render control, and ecosystem maturity. This page compares `@owanturist/signal` and `@owanturist/signal-react` with four popular alternatives — Redux, Zustand, Jotai, and XState — to help you understand where each one fits.

<Callout>
This page compares approaches, not quality. Each library solves real problems well. The best choice depends on your project's constraints, team experience, and what you value most.
</Callout>

## Mental Models [#mental-models]

These libraries differ fundamentally in how they think about state:

- **`@owanturist/signal`** — Fine-grained reactive signals with explicit dependency tracking. State lives outside React in signal instances. A `Monitor{:dart}` parameter makes every dependency visible at the call site.

- **Redux** — A single immutable store with unidirectional data flow. State changes happen through dispatched actions processed by reducers. The indirection is intentional — it creates a predictable, auditable update path. All examples on this page use Redux Toolkit (`@reduxjs/toolkit{:ts}`), the industry-standard extension to the core Redux library.

- **Zustand** — A minimal external store with hook-based subscriptions. No providers, no boilerplate, no opinions. Define state and actions together in a single `create(){:ts}` call.

- **Jotai** — Atomic state with bottom-up composition. Break state into small independent atoms that compose into derived atoms. Conceptually close to signals — both track dependencies between reactive units.

- **XState** — Finite state machines and statecharts. State transitions are explicit and visual. Best suited for complex workflows where modeling possible states prevents bugs that data-centric approaches miss.

## State Ownership and Distribution [#state-distribution]

Where state is created and how it reaches components varies across libraries. Some require specific infrastructure (providers, stores); others let you choose freely.

### Where State Lives [#where-state-lives]

```tsx title="@owanturist/signal"
import { Signal } from "@owanturist/signal"
import { useState } from "react"

// Module scope — accessible anywhere via import
const globalCount = Signal(0)

// Component scope — owned by the component instance
function Counter() {
  const [count] = useState(() => Signal(0))
  return <CounterDisplay count={count} />
}
```

```tsx tab="Redux"
import { configureStore, createSlice } from "@reduxjs/toolkit"
import { Provider } from "react-redux"

// Module scope — singleton store
const store = configureStore({
  reducer: { counter: counterSlice.reducer },
})

// Provider is REQUIRED — components cannot access state without it
function App() {
  return (
    <Provider store={store}>
      <Counter />
    </Provider>
  )
}
```

```tsx tab="Zustand"
import { create } from "zustand"

// Module scope — returns a self-contained hook
const useCounter = create<{
  count: number;
  increment: () => void
}>((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
}))

// No provider needed — the hook works anywhere
function Counter() {
  const count = useCounter((state) => state.count)
  return <span>{count}</span>
}
```

```tsx tab="Jotai"
import { atom, useAtomValue } from "jotai"

// Module scope — atom is a config descriptor, not a value container
const countAtom = atom(0)

// Values live in an implicit global store — no Provider needed
function Counter() {
  const count = useAtomValue(countAtom)
  return <span>{count}</span>
}
```

```tsx tab="XState"
import { useActorRef, useSelector } from "@xstate/react"
import { createActorContext } from "@xstate/react"

// Component scope — useActorRef creates a local actor
function Counter() {
  const actorRef = useActorRef(counterMachine)
  const count = useSelector(actorRef, (s) => s.context.count)
  return <span>{count}</span>
}

// Shared scope — createActorContext provides a Provider
const CounterContext = createActorContext(counterMachine)
```

Redux is the only library that _requires_ a `<Provider>` — components cannot access the store without it. Zustand and Jotai work without providers; their hooks connect to module-level stores directly. XState offers both patterns: `useActorRef(){:ts}` for component-local actors and `createActorContext(){:ts}` for shared access via a Provider. `@owanturist/signal` is the most flexible — signals are plain values that work as module globals, component state via `useState{:ts}`, props, or context, with no library infrastructure at all.

### Passing State Through Components [#passing-state]

```tsx title="@owanturist/signal"
import { ReadableSignal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"

// Passes signal as a prop — DashboardLayout never subscribes
function DashboardLayout({ count }: { count: ReadableSignal<number> }) {
  return (
    <header>
      <h1>Dashboard</h1>
      <CounterBadge count={count} />
    </header>
  )
}

// Only this component subscribes and re-renders
function CounterBadge({ count }: { count: ReadableSignal<number> }) {
  const value = useComputed(count)
  return <span>{value}</span>
}
```

```tsx tab="Redux"
import { useSelector } from "react-redux"

// Any descendant inside Provider reads state directly
function CounterBadge() {
  const count = useSelector((state: RootState) => state.counter.count)
  return <span>{count}</span>
}
```

```tsx tab="Zustand"
import { useCounter } from "./store"

// Any component imports and calls the hook
function CounterBadge() {
  const count = useCounter((state) => state.count)
  return <span>{count}</span>
}
```

```tsx tab="Jotai"
import { useAtomValue } from "jotai"
import { countAtom } from "./atoms"

// Any component reads the atom directly
function CounterBadge() {
  const count = useAtomValue(countAtom)
  return <span>{count}</span>
}
```

```tsx tab="XState"
import { CounterContext } from "./counterContext"

// Shared: descendants use context hooks
function CounterBadge() {
  const count = CounterContext.useSelector((s) => s.context.count)
  return <span>{count}</span>
}

// Local: pass actorRef as a prop
// function CounterBadge({ actorRef }: { actorRef: ActorRefFrom<typeof counterMachine> }) {
//   const count = useSelector(actorRef, (s) => s.context.count)
//   return <span>{count}</span>
// }
```

Redux, Zustand, and Jotai give every component implicit access to shared state — any descendant can reach into the store without receiving anything via props. XState works the same way with `createActorContext(){:ts}`, or you can pass `actorRef{:ts}` explicitly as a prop. `@owanturist/signal` uses explicit passing via props or context — the component tree shows the data flow. The key insight: passing a signal as a prop without reading it creates no subscription and no re-render. Intermediate components are transparent pass-throughs.

### Scoping and Isolation [#scoping-isolation]

State isolation strategies differ significantly:

- **`@owanturist/signal`** — Natural isolation. Create signals inside a component and they're scoped to that instance. Share via props or context as needed. No global state exists unless you explicitly define it at module scope.

- **Redux** — Single global store by convention. Scoping happens through slice design (namespace keys), not provider nesting. Multiple stores are technically possible but discouraged — they break DevTools and complicate state management.

- **Zustand** — One store per `create(){:ts}` call. Multiple independent stores for different domains (auth, cart, UI) is the standard pattern. For per-subtree isolation, a `createStore(){:ts}` + context pattern is available but rarely needed.

- **Jotai** — `<Provider>` creates an isolated atom scope where atoms have independent values. Useful for testing, modals, and repeated widgets that each need their own state. Atoms resolve to the nearest Provider; without one, they use the global store.

- **XState** — `useActorRef(){:ts}` scopes an actor to the component that creates it. `createActorContext(){:ts}` scopes to its Provider subtree — each Provider instance creates a fresh, independent actor.

<Callout type="idea">
See [Using Signals in React](/docs/guides/using-signals-in-react) for detailed patterns on creating signals in components, passing them as props, and distributing them via context.
</Callout>

## Defining and Updating State [#defining-state]

```tsx title="@owanturist/signal"
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"

const count = Signal(0)

function Counter() {
  const value = useComputed(count)

  return (
    <div>
      <span>{value}</span>
      <button onClick={() => count.write(5)}>Set 5</button>
      <button onClick={() => count.write((prev) => prev + 1)}>+</button>
    </div>
  )
}
```

```tsx tab="Redux"
import { createSlice, configureStore } from "@reduxjs/toolkit"
import { Provider, useSelector, useDispatch } from "react-redux"

const counterSlice = createSlice({
  name: "counter",
  initialState: { count: 0 },
  reducers: {
    increment: (state) => { state.count += 1 },
    set: (state, action) => { state.count = action.payload },
  },
})

const store = configureStore({
  reducer: { counter: counterSlice.reducer },
})

type RootState = ReturnType<typeof store.getState>

function Counter() {
  const value = useSelector((state: RootState) => state.counter.count)
  const dispatch = useDispatch()

  return (
    <div>
      <span>{value}</span>
      <button onClick={() => dispatch(counterSlice.actions.set(5))}>Set 5</button>
      <button onClick={() => dispatch(counterSlice.actions.increment())}>+</button>
    </div>
  )
}

function App() {
  return (
    <Provider store={store}>
      <Counter />
    </Provider>
  )
}
```

```tsx tab="Zustand"
import { create } from "zustand"

const useCounter = create<{
  count: number
  set: (n: number) => void
  increment: () => void
}>((set) => ({
  count: 0,
  set: (n) => set({ count: n }),
  increment: () => set((state) => ({ count: state.count + 1 })),
}))

function Counter() {
  const value = useCounter((state) => state.count)
  const set = useCounter((state) => state.set)
  const increment = useCounter((state) => state.increment)

  return (
    <div>
      <span>{value}</span>
      <button onClick={() => set(5)}>Set 5</button>
      <button onClick={increment}>+</button>
    </div>
  )
}
```

```tsx tab="Jotai"
import { atom, useAtomValue, useSetAtom } from "jotai"

const countAtom = atom(0)

function Counter() {
  const value = useAtomValue(countAtom)
  const setCount = useSetAtom(countAtom)

  return (
    <div>
      <span>{value}</span>
      <button onClick={() => setCount(5)}>Set 5</button>
      <button onClick={() => setCount((prev) => prev + 1)}>+</button>
    </div>
  )
}
```

```tsx tab="XState"
import { setup, assign } from "xstate"
import { useActorRef, useSelector } from "@xstate/react"

const counterMachine = setup({
  types: {
    context: {} as { count: number },
    events: {} as
      | { type: "increment" }
      | { type: "set"; value: number },
  },
}).createMachine({
  context: { count: 0 },
  on: {
    increment: {
      actions: assign({ count: ({ context }) => context.count + 1 }),
    },
    set: {
      actions: assign({ count: ({ event }) => event.value }),
    },
  },
})

function Counter() {
  const actorRef = useActorRef(counterMachine)
  const value = useSelector(actorRef, (s) => s.context.count)

  return (
    <div>
      <span>{value}</span>
      <button onClick={() => actorRef.send({ type: "set", value: 5 })}>Set 5</button>
      <button onClick={() => actorRef.send({ type: "increment" })}>+</button>
    </div>
  )
}
```

Every library ends up in a React component, but the path there varies. Redux requires the most ceremony — slices, reducers, a store, typed hooks, and a `<Provider>` — before a component can read or write a value. XState is similar: machine definitions, event types, and `useActorRef(){:ts}` + `useSelector(){:ts}` in the component. Zustand collapses state and actions into a single `create(){:ts}` call, and the resulting hook works without a provider. Jotai and `@owanturist/signal` are the most concise — a single function call creates a reactive value, and a single hook reads it.

## Reading State in React [#reading-in-react]

```tsx title="@owanturist/signal — useMonitor"
import { useMonitor } from "@owanturist/signal-react"

function Counter() {
  const monitor = useMonitor()
  const value = count.read(monitor)
  const doubled = count.read(monitor) * 2
  return <p>{value} / {doubled}</p>
}
```

```tsx tab="useComputed"
import { useComputed } from "@owanturist/signal-react"

function Counter() {
  const value = useComputed(count)
  const doubled = useComputed((monitor) => count.read(monitor) * 2, [])
  return <p>{value} / {doubled}</p>
}
```

```tsx tab="Redux"
import { useSelector, useDispatch } from "react-redux"

function Counter() {
  const value = useSelector((state: RootState) => state.counter.count)
  const doubled = useSelector((state: RootState) => state.counter.count * 2)
  const dispatch = useDispatch()
  return (
    <div>
      <p>{value} / {doubled}</p>
      <button onClick={() => dispatch(counterSlice.actions.increment())}>+</button>
    </div>
  )
}
```

```tsx tab="Zustand"
function Counter() {
  const value = useCounter((state) => state.count)
  const doubled = useCounter((state) => state.count * 2)
  const increment = useCounter((state) => state.increment)
  return (
    <div>
      <p>{value} / {doubled}</p>
      <button onClick={increment}>+</button>
    </div>
  )
}
```

```tsx tab="Jotai"
import { useAtomValue, useSetAtom } from "jotai"

function Counter() {
  const value = useAtomValue(countAtom)
  const doubled = useAtomValue(doubledAtom)
  const setCount = useSetAtom(countAtom)
  return (
    <div>
      <p>{value} / {doubled}</p>
      <button onClick={() => setCount((c) => c + 1)}>+</button>
    </div>
  )
}
```

```tsx tab="XState"
import { useActorRef, useSelector } from "@xstate/react"

function Counter() {
  const actorRef = useActorRef(counterMachine)
  const value = useSelector(actorRef, (s) => s.context.count)
  const doubled = useSelector(actorRef, (s) => s.context.count * 2)
  return (
    <div>
      <p>{value} / {doubled}</p>
      <button onClick={() => actorRef.send({ type: "increment" })}>+</button>
    </div>
  )
}
```

All five libraries use external stores subscribed via hooks — none rely on React context for state delivery. The main differences are in how you select state slices and how updates are triggered. Redux, Zustand, and XState use selector functions. Jotai selects at the atom level. `@owanturist/signal` offers two hooks — `useMonitor(){:ts}` returns a monitor for reading signals directly in the render body, while `useComputed(){:ts}` accepts a signal reference or a factory function for memoized derivations.

## Re-render Optimization [#re-render-optimization]

```tsx title="@owanturist/signal"
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"

const firstName = Signal("John")
const lastName = Signal("Doe")

function FullName() {
  // Subscribes to both firstName and lastName
  const full = useComputed((monitor) => {
    return `${firstName.read(monitor)} ${lastName.read(monitor)}`
  }, [])

  return <span>{full}</span>
}

function FirstNameOnly() {
  // Subscribes to firstName only — lastName changes never cause re-renders
  const first = useComputed(firstName)
  return <span>{first}</span>
}
```

```tsx tab="Redux"
import { useSelector } from "react-redux"

function FullName() {
  // Selector runs on EVERY store dispatch, even unrelated ones
  const full = useSelector(
    (state: RootState) => `${state.user.firstName} ${state.user.lastName}`,
  )
  return <span>{full}</span>
}

function FirstNameOnly() {
  // Still runs on every dispatch — only skips re-render if result unchanged
  const first = useSelector((state: RootState) => state.user.firstName)
  return <span>{first}</span>
}
```

```tsx tab="Zustand"
import { useUserStore } from "./store"

function FullName() {
  // Selector runs on every store update
  const full = useUserStore(
    (state) => `${state.firstName} ${state.lastName}`,
  )
  return <span>{full}</span>
}

function FirstNameOnly() {
  const first = useUserStore((state) => state.firstName)
  return <span>{first}</span>
}
```

```tsx tab="Jotai"
import { atom, useAtomValue } from "jotai"

const firstNameAtom = atom("John")
const lastNameAtom = atom("Doe")
const fullNameAtom = atom(
  (get) => `${get(firstNameAtom)} ${get(lastNameAtom)}`,
)

function FullName() {
  // Subscribes to fullNameAtom — re-renders only when it changes
  const full = useAtomValue(fullNameAtom)
  return <span>{full}</span>
}

function FirstNameOnly() {
  // Subscribes to firstNameAtom only
  const first = useAtomValue(firstNameAtom)
  return <span>{first}</span>
}
```

```tsx tab="XState"
import { useSelector } from "@xstate/react"

function FullName({ actorRef }: { actorRef: ActorRefFrom<typeof userMachine> }) {
  const full = useSelector(
    actorRef,
    (s) => `${s.context.firstName} ${s.context.lastName}`,
  )
  return <span>{full}</span>
}

function FirstNameOnly({ actorRef }: { actorRef: ActorRefFrom<typeof userMachine> }) {
  const first = useSelector(actorRef, (s) => s.context.firstName)
  return <span>{first}</span>
}
```

Re-render behavior is where these libraries diverge most:

- **`@owanturist/signal`** — The Monitor tracks exactly which signals each `useComputed(){:ts}` call reads. The compute function only re-runs when one of those specific signals changes — writes to unrelated signals are invisible. Dependencies are dynamic: if a conditional branch skips reading a signal, that signal won't cause re-renders. On top of that, each signal can define a custom `equals{:ts}` option that prevents propagation at the source — if a write produces a value equal to the current one, no subscribers are notified at all. `useComputed(){:ts}` then applies its own `equals{:ts}` as a second gate: if the compute result hasn't changed, no re-render is enqueued.

- **Redux** — The selector function passed to `useSelector(){:ts}` runs on **every** store dispatch, regardless of which slice changed. Re-renders are skipped only when the result passes the equality check (`===` by default, customizable via `useSelector(selector, equalityFn){:ts}`). The selector computation cost is paid unconditionally. For derived values, `createSelector(){:ts}` from reselect adds memoization to avoid recomputing when inputs haven't changed.

- **Zustand** — Similar to Redux — selectors with `===` comparison. `useShallow(){:ts}` adds shallow comparison for object/array selectors. Zustand also supports transient updates via `subscribe(){:ts}` for high-frequency changes that bypass React entirely.

- **Jotai** — Atom-level subscriptions. Components only re-render when consumed atoms change. `useSetAtom(){:ts}` subscribes to nothing — write-only access without re-renders. Closest to signals in granularity.

- **XState** — `useSelector(){:ts}` selects specific state slices, re-rendering only when the selected value changes. The machine structure naturally constrains which state transitions are possible, reducing unexpected updates.

Jotai and `@owanturist/signal` provide the finest granularity out of the box — compute functions only run when their actual dependencies change. Redux and Zustand selectors run on every dispatch, relying on equality checks to prevent unnecessary re-renders. `@owanturist/signal` adds a unique two-level equality system: signal-level `equals{:ts}` prevents propagation at the source, and `useComputed(){:ts}`-level `equals{:ts}` prevents re-renders from identical results. XState's structured approach sidesteps the problem differently — by making state transitions explicit.

## Derived State and Composition [#derived-state]

```ts title="@owanturist/signal"
import { Signal } from "@owanturist/signal"

const count = Signal(0)
const doubled = Signal((monitor) => count.read(monitor) * 2)
const quadrupled = Signal((monitor) => doubled.read(monitor) * 2)
```

```ts tab="Redux"
import { createSelector } from "@reduxjs/toolkit"

const selectCount = (state: RootState) => state.counter.count
const selectDoubled = createSelector(selectCount, (count) => count * 2)
const selectQuadrupled = createSelector(selectDoubled, (doubled) => doubled * 2)
```

```ts tab="Zustand"
// Derived values are typically computed in selectors
function Component() {
  const doubled = useCounter((state) => state.count * 2)
  const quadrupled = useCounter((state) => state.count * 4)
}
```

```ts tab="Jotai"
import { atom } from "jotai"

const countAtom = atom(0)
const doubledAtom = atom((get) => get(countAtom) * 2)
const quadrupledAtom = atom((get) => get(doubledAtom) * 2)
```

```ts tab="XState"
// XState has no built-in derived state.
// Use selector functions on state snapshots:
const selectDoubled = (state) => state.context.count * 2
const selectQuadrupled = (state) => state.context.count * 4
```

Jotai and `@owanturist/signal` handle derived state most naturally — derived atoms and derived signals compose freely and track dependencies automatically. Redux requires `createSelector(){:ts}` chains for memoized derivations. Zustand computes derived values in selectors at read time, which is simple but recomputes on every render unless you add external memoization. XState delegates derivation to selectors since machines model transitions, not computations.

## Middleware, Devtools, and Ecosystem [#ecosystem]

Redux has the most mature ecosystem of any React state library. Redux DevTools provides time-travel debugging, action replay, and state diffing. Redux Toolkit Query handles data fetching and caching. Middleware like thunks and sagas cover async workflows. If ecosystem breadth and battle-tested tooling are priorities, Redux is hard to beat.

Zustand offers a lean middleware system — `persist{:ts}` for localStorage, `devtools{:ts}` for Redux DevTools integration, `immer{:ts}` for mutable update syntax. It strikes a balance between simplicity and extensibility.

Jotai provides `jotai-devtools{:ts}`, Suspense integration, and utilities like `atomWithStorage(){:ts}` for persistence. Its atom model integrates well with React's concurrent features.

XState offers Stately Studio — a visual editor for designing state machines — alongside `@xstate/inspect{:ts}` for runtime visualization and `@xstate/test{:ts}` for model-based testing.

`@owanturist/signal` has a minimal ecosystem. There are no devtools, no middleware system, and no persistence utilities. `@owanturist/signal-form{:ts}` provides form state management. The library focuses on a small, correct core rather than breadth.

<Callout type="warn">
If your team relies on devtools for debugging state changes, consider Redux or Zustand with the devtools middleware. `@owanturist/signal` does not currently provide debugging tools.
</Callout>

## TypeScript Experience [#typescript]

```ts title="@owanturist/signal"
import { Signal } from "@owanturist/signal"

// Full inference — no type annotations needed
const count = Signal(0)               // WritableSignal<number>
const name = Signal("Alice")          // WritableSignal<string>
const doubled = Signal((monitor) =>   // ReadableSignal<number>
  count.read(monitor) * 2,
)
```

```ts tab="Redux"
import { configureStore, createSlice } from "@reduxjs/toolkit"

const userSlice = createSlice({
  name: "user",
  initialState: { name: "Alice", age: 30 },
  reducers: {
    setName: (state, action: PayloadAction<string>) => {
      state.name = action.payload
    },
  },
})

const store = configureStore({ reducer: { user: userSlice.reducer } })

// Manual type definitions required
type RootState = ReturnType<typeof store.getState>
type AppDispatch = typeof store.dispatch

// Pre-typed hooks to avoid repeating RootState everywhere
const useAppSelector = useSelector.withTypes<RootState>()
const useAppDispatch = useDispatch.withTypes<AppDispatch>()
```

```ts tab="Zustand"
import { create } from "zustand"

// Type parameter required on create<T>() for full type safety
const useStore = create<{
  name: string
  age: number
  setName: (name: string) => void
}>((set) => ({
  name: "Alice",
  age: 30,
  setName: (name) => set({ name }),
}))
```

```ts tab="Jotai"
import { atom } from "jotai"

// Full inference — similar to signals
const nameAtom = atom("Alice")              // PrimitiveAtom<string>
const ageAtom = atom(30)                    // PrimitiveAtom<number>
const greetingAtom = atom(                  // Atom<string>
  (get) => `Hello, ${get(nameAtom)}!`,
)
```

```ts tab="XState"
import { setup, assign } from "xstate"

// Types defined in setup() — verbose but catches invalid transitions
const userMachine = setup({
  types: {
    context: {} as { name: string; age: number },
    events: {} as
      | { type: "setName"; name: string }
      | { type: "incrementAge" },
  },
}).createMachine({
  context: { name: "Alice", age: 30 },
  on: {
    setName: { actions: assign({ name: ({ event }) => event.name }) },
    incrementAge: { actions: assign({ age: ({ context }) => context.age + 1 }) },
  },
})
```

All five libraries support TypeScript, but the ergonomics differ:

- **`@owanturist/signal`** — Full inference. `Signal(0){:ts}` infers `WritableSignal<number>{:dart}`. Derived signals infer their return type. Rarely needs annotations.

- **Redux** — Good inference within slices, but requires manual `RootState{:dart}` and `AppDispatch{:dart}` type definitions. `useSelector(){:ts}` is context-based — it reads from whichever `<Provider>` wraps the component, but TypeScript cannot infer the store shape from React context. You must create pre-typed hooks via `useSelector.withTypes<RootState>(){:ts}` (or the older `TypedUseSelectorHook{:dart}` pattern) and use them everywhere. Multiple stores compound the problem: each needs its own `RootState{:dart}` and its own typed hooks, with no mechanism for TypeScript to resolve which store applies from context alone.

- **Zustand** — Requires an interface or type parameter on `create<T>(){:ts}` for full type safety. Selectors and actions infer types from the store definition.

- **Jotai** — Excellent inference, similar to signals. `atom(0){:ts}` infers `PrimitiveAtom<number>{:dart}`. Derived atoms auto-infer. Annotations are rarely needed.

- **XState** — The `setup(){:ts}` API provides good type safety for context, events, and actions. More verbose than atom-based libraries due to the machine structure, but the types catch invalid transitions at compile time.

## Learning Curve [#learning-curve]

Learning curve depends on two factors: how many concepts you need to learn before writing productive code, and how familiar those concepts are from existing React and JavaScript knowledge.

- **Zustand** — Flattest learning curve. `create()` returns a hook; call it with a selector. If you know React hooks and plain objects, you already know Zustand. The mental model is "a global `useState` with selectors."

- **Jotai** — Low barrier. Atoms look like signals: `atom(0)` for primitive, `atom((get) => ...)` for derived. The `get` parameter maps to React's `useMemo` intuition. The only new concept is that atoms are config descriptors whose values live in an implicit store.

- **`@owanturist/signal`** — Small API surface, but the [`Monitor`](/docs/concepts/how-signals-work-in-react) parameter is a genuinely novel concept — no other mainstream library uses explicit dependency-tracking tokens passed at the call site. Once you understand that `signal.read(monitor)` both returns a value and registers a dependency, everything else follows a single coherent pattern. The [getting-started guide](/docs/getting-started) introduces concepts in a natural progression: [`Signal`](/docs/api/signal) → [read/write](/docs/guides/reading-and-writing-signals) → [derived signals](/docs/api/signal#derived-readonly) → [`effect`](/docs/api/effect) → [`batch`](/docs/api/batch) → [`useComputed`](/docs/api/use-computed).

- **Redux** — Steepest boilerplate curve. Even with Redux Toolkit reducing ceremony, you must learn slices, reducers, actions, dispatch, the store, `<Provider>`, and pre-typed hooks before a single value reaches a component. The concepts themselves aren't complex, but the indirection (action → reducer → store → selector → component) takes time to internalize. The payoff is a predictable, auditable architecture for large teams.

- **XState** — Steepest conceptual curve. Before writing any working code, you need to understand finite state machines: states, transitions, events, context, guards, and actions. This is a paradigm shift from data-centric state management. The `setup()` API helps with TypeScript, but the machine definition language is substantial. The payoff is that impossible states become unrepresentable.

Zustand and Jotai are the fastest to get started with. `@owanturist/signal` requires learning the Monitor concept but rewards that investment with a small, consistent API. Redux and XState have the longest ramp-up, but their structure pays dividends in complex applications where predictability and explicit modeling matter.

<Callout>
Learning curve is not the same as long-term productivity. A library that takes longer to learn may save more time over the life of a project by preventing bugs or reducing cognitive load in complex state flows.
</Callout>

## Bundle Size [#bundle-size]

| Library | Packages | Gzipped Size |
| --- | --- | --- |
| Zustand | `zustand` | ~1.2 kB |
| `@owanturist/signal` | `signal` + `signal-react` | ~2.6 kB |
| Jotai | `jotai` | ~3.6 kB |
| Redux | `@reduxjs/toolkit` + `react-redux` | ~15 kB |
| XState | `xstate` + `@xstate/react` | ~17 kB |

Zustand is the smallest. `@owanturist/signal` and Jotai sit in a similar range. Redux and XState are significantly larger, though both provide substantially more built-in functionality. Bundle size rarely determines library choice on its own, but it matters for applications targeting constrained environments or strict performance budgets.

## Framework Independence [#framework-independence]

The core `@owanturist/signal` package has zero dependencies and works in any JavaScript environment — Node.js, Deno, browsers, or edge runtimes (Cloudflare Workers, Vercel Edge Functions, etc.). Only `@owanturist/signal-react` introduces a React peer dependency.

```ts title="Vanilla JavaScript"
import { Signal, effect } from "@owanturist/signal"

const count = Signal(0)
const doubled = Signal((monitor) => count.read(monitor) * 2)

effect((monitor) => {
  console.log(`doubled: ${doubled.read(monitor)}`)
})

count.write(5) // logs "doubled: 10"
```

Redux's core is also framework-agnostic, though Redux Toolkit and react-redux are React-specific. Zustand and Jotai are React-first but offer `/vanilla` subpath exports. XState is fully framework-agnostic with official bindings for React, Vue, Svelte, and Solid.

## When to Choose What [#when-to-choose]

**Choose `@owanturist/signal` when** you want fine-grained reactivity with a small API surface. Signals work well for applications where precise re-render control matters and you prefer explicit dependency tracking over selector-based patterns.

**Choose Redux when** you need a mature ecosystem with devtools, middleware, and established patterns. Redux excels in large teams where predictability, auditability, and standardized architecture reduce coordination costs.

**Choose Zustand when** you want the simplest possible external store. Zustand's minimal API and tiny bundle make it a good default for applications that don't need fine-grained reactivity or complex state machines.

**Choose Jotai when** you want atomic state composition with excellent React integration. Jotai's model is conceptually similar to signals — if you prefer implicit dependency tracking and tight Suspense integration, Jotai is worth evaluating.

**Choose XState when** your state has complex transitions, guards, and side effects that benefit from visual modeling. State machines prevent entire categories of bugs by making impossible states unrepresentable.

## See Also [#see-also]

<Cards>
  <Card title="Design Decisions" href="/docs/concepts/design-decisions" />
  <Card title="How Signals Work in React" href="/docs/concepts/how-signals-work-in-react" />
  <Card title="Fundamentals" href="/docs/concepts/fundamentals" />
</Cards>
