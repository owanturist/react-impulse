---
title: Signals and Monitors
description: Understanding the core reactive primitives and how they work together
---

At the heart of this library are two concepts that work together to create reactive applications: **Signals** hold values, and **Monitors** track who is reading them. Understanding their relationship is key to using the library effectively.

## The Core Idea

A Signal is a container for a value that can change over time. But what makes it reactive? How does the system know to re-run your code when a signal changes?

The answer is the **Monitor**.

```ts
import { Signal, effect } from "@owanturist/signal"

const count = Signal(0)

effect((monitor) => {
  console.log(count.read(monitor)) // 0
})

count.write(1) // Effect re-runs, logs: 1
```

When you call `count.read(monitor)`, two things happen:
1. The signal returns its current value
2. The signal records that this monitor is interested in its value

Later, when `count.write(1)` changes the value, the signal notifies all monitors that previously read it. Those monitors then trigger their associated code to re-run.

## Why Monitors Exist

Consider this question: when a signal's value changes, how should the system know what code to re-execute?

One approach would be to track everything globally. But that creates problems - what if you read a signal inside a condition that's only true sometimes? What if you want to read a value without triggering updates?

The Monitor solves this by making dependency tracking **explicit** and **scoped**:

```ts
const theme = Signal("light")
const fontSize = Signal(14)

effect((monitor) => {
  // This monitor now "watches" theme
  document.body.className = theme.read(monitor)
})

effect((monitor) => {
  // This monitor now "watches" fontSize
  document.body.style.fontSize = `${fontSize.read(monitor)}px`
})

theme.write("dark")    // Only the first effect re-runs
fontSize.write(16)     // Only the second effect re-runs
```

Each effect gets its own monitor. When `theme` changes, it only notifies the monitors that actually read it - not every effect in your application.

## The Read-Write Cycle

Signals have two fundamental operations:

### Reading with `.read(monitor)`

Reading requires a monitor because that's how the signal knows who to notify later:

```ts
const name = Signal("Alice")

effect((monitor) => {
  // The signal records: "this monitor cares about my value"
  const value = name.read(monitor)
  console.log(`Hello, ${value}`)
})
```

### Writing with `.write()`

Writing doesn't need a monitor - it just updates the value and notifies all watching monitors:

```ts
name.write("Bob")
// All monitors that called .read() are notified
// Their associated effects/computations re-run
```

You can also write using a transform function:

```ts
const count = Signal(0)

count.write(5)                    // Set directly
count.write((current) => current + 1)  // Transform: count is now 6
```

## Dynamic Dependency Tracking

The beauty of the Monitor system is that dependencies are tracked **dynamically** based on what actually gets read:

```ts
const showDetails = Signal(false)
const summary = Signal("Brief info")
const details = Signal("Full details here...")

effect((monitor) => {
  if (showDetails.read(monitor)) {
    // When showDetails is true, this effect depends on both signals
    console.log(details.read(monitor))
  } else {
    // When showDetails is false, it only depends on showDetails and summary
    console.log(summary.read(monitor))
  }
})
```

When `showDetails` is `false`, changing `details` does nothing - the effect didn't read it on the last run, so no monitor is watching it.

This happens automatically. You don't need to declare dependencies upfront. The system figures it out based on what your code actually reads.

## Derived Signals

Signals can also compute their value from other signals:

```ts
const price = Signal(100)
const quantity = Signal(2)

// Derived signal - computes its value from others
const total = Signal((monitor) => price.read(monitor) * quantity.read(monitor))

effect((monitor) => {
  console.log(`Total: $${total.read(monitor)}`) // Total: $200
})

price.write(150) // Effect logs: Total: $300
```

The derived signal receives a monitor just like effects do. When you read `price` and `quantity` inside it, those signals start watching the derived signal's monitor. When either source changes, the derived signal recomputes.

Derived signals are covered in detail in the [Derived Signals](/docs/concepts/derived) page.

## Reading Without Tracking

Sometimes you need to read a signal's value without establishing a dependency. Use `untracked`:

```ts
import { Signal, effect, untracked } from "@owanturist/signal"

const count = Signal(0)
const multiplier = Signal(2)

effect((monitor) => {
  // count is tracked - effect re-runs when it changes
  // multiplier is NOT tracked - effect ignores its changes
  const result = count.read(monitor) * untracked((m) => multiplier.read(m))
  console.log(result)
})

count.write(5)       // Effect runs, logs: 10
multiplier.write(3)  // Effect does NOT run
count.write(5)       // Effect runs, logs: 15 (picks up new multiplier)
```

## Summary

The Signal + Monitor pattern is the foundation of reactivity in this library:

- **Signals** hold values and notify monitors when values change
- **Monitors** track which signals have been read, establishing dependencies
- **`.read(monitor)`** returns the value AND registers the monitor as a watcher
- **`.write()`** updates the value AND notifies all watching monitors
- Dependencies are tracked dynamically based on actual code execution

This design gives you fine-grained control over reactivity while keeping the mental model simple: pass a monitor when reading, and the system handles the rest.

## See Also

- [Signal API Reference](/docs/api/signal) - Complete API documentation
- [Derived Signals](/docs/concepts/derived) - Computing values from signals
- [Effects](/docs/concepts/effects) - Side effects and cleanup
