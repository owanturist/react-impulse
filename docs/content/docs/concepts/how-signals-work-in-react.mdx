---
title: How Signals Work in React
description: How signals integrate with React's rendering model
---

This page explains why signals work well with React and how the `@owanturist/signal-react` package bridges the two systems. For core signal concepts, see [Core Reactivity](/docs/concepts/fundamentals).

## Why Signals in React?

React's built-in state primitives (`useState{:dart}`, `useReducer{:dart}`) use a coarse-grained update model: when state changes, the entire component and its children re-render. You can optimize this with `memo{:dart}`, `useMemo{:dart}`, and `useCallback{:dart}`, but it requires manual work.

Signals offer fine-grained reactivity. Only components that actually read a changed signal re-render, automatically:

```tsx
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"

const firstName = Signal("John")
const lastName = Signal("Doe")

function FirstNameDisplay() {
  const first = useComputed(firstName)
  // Only re-renders when firstName changes
  return <span>{first}</span>
}

function LastNameDisplay() {
  const last = useComputed(lastName)
  // Only re-renders when lastName changes
  return <span>{last}</span>
}
```

When `firstName` changes, only `FirstNameDisplay` re-renders.

## The useSyncExternalStore Bridge

React 18 introduced `useSyncExternalStore` for safe external state integration with concurrent rendering. The `@owanturist/signal-react` package uses it internally.

When you call `useComputed(signal){:ts}`:

1. A Monitor is created to track signal reads
2. The compute function runs, reading signals through the Monitor
3. Each signal records the Monitor as a subscriber
4. When any signal changes, it notifies the Monitor
5. `useSyncExternalStore` schedules a re-render

This happens automatically. You write simple code, and the library handles React integration.

## Using Monitors in Components

The `useComputed{:dart}` hook provides a `Monitor{:dart}` to your compute function:

```tsx
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"

const a = Signal(1)
const b = Signal(2)
const c = Signal(3)

function Sum() {
  const total = useComputed((monitor) => {
    return a.read(monitor) + b.read(monitor) + c.read(monitor)
  }, [])

  return <div>Total: {total}</div>
}
```

Dependencies are tracked dynamically. If your compute function conditionally reads signals, the subscriptions update automatically:

```tsx
const showDetails = Signal(false)
const summary = Signal("Brief")
const details = Signal("Full details...")

function Content() {
  const text = useComputed((monitor) => {
    if (showDetails.read(monitor)) {
      return details.read(monitor)
    }
    return summary.read(monitor)
  }, [])

  return <div>{text}</div>
}
```

When `showDetails` is `false`, changing `details` does not trigger a re-render.

## Sharing State Across Components [#sharing-state]

Signal references are stable - updating a value does not change the reference. Pass them via props or context like any other value. Only components that read a signal re-render when it changes.

```tsx
import { Signal, ReadableSignal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"
import { useState } from "react"

function SearchPage() {
  const [query] = useState(() => Signal(""))

  return (
    <div>
      <SearchInput query={query} />
      <SearchResults query={query} />
    </div>
  )
}

function SearchInput({ query }: { query: Signal<string> }) {
  const value = useComputed(query)

  return (
    <input
      value={value}
      onChange={({ target }) => query.write(target.value)}
    />
  )
}

function SearchResults({ query }: { query: ReadableSignal<string> }) {
  const value = useComputed(query)

  return <p>Results for "{value}"</p>
}
```

The `SearchPage` component creates the signal and passes it down. Both children subscribe independently -- typing in the input updates the results without re-rendering `SearchPage`.

See [Using Signals in React](/docs/guides/using-signals-in-react) for more patterns including props, context, and creating signals inside components.

## Dynamic Signal Collections

Signals compose naturally inside data structures. When each item holds its own signal, updates to one item only re-render the component reading that signal -- the list itself only re-renders when items are added or removed.

```tsx
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"

interface Todo {
  id: string
  text: string
  completed: Signal<boolean>
}

function TodoList({ todos }: { todos: Signal<Todo[]> }) {
  const items = useComputed(todos)

  return (
    <ul>
      {items.map((todo) => (
        <TodoItem key={todo.id} todo={todo} />
      ))}
    </ul>
  )
}

function TodoItem({ todo }: { todo: Todo }) {
  const completed = useComputed(todo.completed)

  return (
    <li style={{ textDecoration: completed ? "line-through" : "none" }}>
      {todo.text}
      <button onClick={() => todo.completed.write(!completed)}>Toggle</button>
    </li>
  )
}
```

Toggling `todo.completed` only re-renders that `TodoItem`. The parent list is unaffected.

## Design Trade-offs

### Signals vs Context

React Context is built-in and familiar, but has limitations:

| Aspect | Signals | Context |
|--------|---------|---------|
| Update granularity | Fine-grained (only readers re-render) | Coarse-grained (all consumers re-render) |
| Subscription | Automatic based on reads | Must wrap with Consumer or useContext |
| Computed values | Built-in derived signals | Requires manual memoization |
| External access | Works outside React | React-only |

Signals work well alongside Context. Use Context for dependency injection (passing down signal instances) and signals for reactive state.

### When to Use Signals vs useState

Use **useState** when:
- State is truly local to one component
- State doesn't need to be shared
- You want to keep things simple for small components

Use **signals** when:
- State is shared across multiple components
- You need computed values that depend on multiple pieces of state
- You want automatic fine-grained updates
- You need to access state outside React (effects, event handlers)

## Dynamic Dependency Tracking in Components

When you call `signal.read(monitor){:ts}` inside the compute function, that signal becomes a dependency. The component re-renders when any dependency changes:

```tsx
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"

const a = Signal(1)
const b = Signal(2)
const useB = Signal(true)

function Component() {
  const value = useComputed((monitor) => {
    if (useB.read(monitor)) {
      return a.read(monitor) + b.read(monitor)
    }
    return a.read(monitor)
  }, [])

  return <div>{value}</div>
}
```

When `useB` is `true`, the component depends on `a`, `b`, and `useB`. When `useB` becomes `false`, the component only depends on `a` and `useB`. Dependencies are re-evaluated on every render based on which signals were actually read.

## Debug Support

The computed value is exposed to React DevTools via `useDebugValue`, making it easy to inspect signal values during debugging.

## Memory Safety

The signal-react integration uses WeakRef internally for subscriptions. This means:

- Components that unmount are automatically cleaned up
- No manual subscription management needed
- No memory leaks from forgotten unsubscribes

## See Also

<Cards>
  <Card title="Fundamentals" description="Core signal concepts" href="/docs/concepts/fundamentals" />
  <Card title="useComputed API" description="Complete hook reference" href="/docs/api/use-computed" />
  <Card title="useMonitor API" description="Direct monitor access" href="/docs/api/use-monitor" />
</Cards>
