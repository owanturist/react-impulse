---
title: React Integration
description: Understanding how signals integrate with React's rendering model
---

This page explains why signals work well with React and how the `@owanturist/signal-react` package bridges the two systems.

## Why Signals in React?

React's built-in state primitives (`useState`, `useReducer`) use a coarse-grained update model: when state changes, the entire component and its children re-render. You can optimize this with `memo`, `useMemo`, and `useCallback`, but it requires manual work.

Signals offer fine-grained reactivity. Only components that actually read a changed signal re-render, automatically. No manual memoization needed.

```tsx
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"

const firstName = Signal("John")
const lastName = Signal("Doe")

function FirstNameDisplay() {
  const first = useComputed(firstName)
  // Only re-renders when firstName changes
  return <span>{first}</span>
}

function LastNameDisplay() {
  const last = useComputed(lastName)
  // Only re-renders when lastName changes
  return <span>{last}</span>
}
```

When `firstName` changes, only `FirstNameDisplay` re-renders. `LastNameDisplay` is unaffected because it doesn't read `firstName`.

## The useSyncExternalStore Bridge

React 18 introduced `useSyncExternalStore`, a hook specifically designed for integrating external state management with React's concurrent rendering. The `@owanturist/signal-react` package uses this hook internally.

### Why useSyncExternalStore?

Before React 18, integrating external state with React was error-prone. During concurrent rendering, components could read inconsistent state (a problem called "tearing"). `useSyncExternalStore` solves this by:

1. **Ensuring consistent reads** - All components see the same state value during a render pass
2. **Automatic subscription** - React manages subscribe/unsubscribe lifecycle
3. **Server rendering support** - Works correctly during SSR

### How It Works

When you call `useComputed(signal)`:

1. A `MonitorFactory` creates a Monitor for tracking reads
2. The compute function runs, reading signals through the Monitor
3. Each signal records the Monitor as a subscriber
4. When any signal changes, it notifies the Monitor
5. The Monitor triggers React's subscription callback
6. `useSyncExternalStore` schedules a re-render

This happens automatically. You write simple code, and the library handles React integration.

## The Monitor Pattern in Components

The Monitor is the key abstraction that makes automatic dependency tracking work. In React components, the `useComputed` hook provides a Monitor to your compute function:

```tsx
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"

const a = Signal(1)
const b = Signal(2)
const c = Signal(3)

function Sum() {
  const total = useComputed((monitor) => {
    // Reading a, b, c establishes them as dependencies
    return a.read(monitor) + b.read(monitor) + c.read(monitor)
  }, [])

  return <div>Total: {total}</div>
}
```

The Monitor tracks exactly which signals were read during the last execution. If your compute function conditionally reads signals, the dependencies update automatically:

```tsx
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"

const showDetails = Signal(false)
const summary = Signal("Brief")
const details = Signal("Full details...")

function Content() {
  const text = useComputed((monitor) => {
    if (showDetails.read(monitor)) {
      return details.read(monitor)
    }
    return summary.read(monitor)
  }, [])

  return <div>{text}</div>
}
```

When `showDetails` is `false`, changing `details` does not trigger a re-render. The component only subscribes to signals it actually reads.

## Design Trade-offs

### Signals vs Context

React Context is built-in and familiar, but has limitations:

| Aspect | Signals | Context |
|--------|---------|---------|
| Update granularity | Fine-grained (only readers re-render) | Coarse-grained (all consumers re-render) |
| Subscription | Automatic based on reads | Must wrap with Consumer or useContext |
| Computed values | Built-in derived signals | Requires manual memoization |
| External access | Works outside React | React-only |

Signals work well alongside Context. Use Context for dependency injection (passing down signal instances) and signals for reactive state.

### When to Use Signals vs useState

Use **useState** when:
- State is truly local to one component
- State doesn't need to be shared
- You want to keep things simple for small components

Use **signals** when:
- State is shared across multiple components
- You need computed values that depend on multiple pieces of state
- You want automatic fine-grained updates
- You need to access state outside React (effects, event handlers)

## Memory Safety

The signal-react integration uses WeakRef internally for subscriptions. This means:

- Components that unmount are automatically cleaned up
- No manual subscription management needed
- No memory leaks from forgotten unsubscribes

## Summary

- Signals provide fine-grained reactivity that complements React's rendering model
- `useSyncExternalStore` ensures safe integration with concurrent rendering
- The Monitor pattern enables automatic dependency tracking
- `useComputed` is the primary hook for reading signals in components
- Signals can coexist with React's built-in state when appropriate

## See Also

- [useComputed API](/docs/api/use-computed) - Complete hook reference
- [useMonitor API](/docs/api/use-monitor) - Low-level monitor access
- [Using Signals in React Components](/docs/guides/react-components) - Practical patterns
