---
title: Design Decisions
description: Why @owanturist/signal's API is shaped the way it is — informed by signals in Angular, Solid, Preact, Vue, Svelte, and Qwik
---

Signals are a proven reactive pattern. Angular, Solid, Preact, Vue, Svelte, and Qwik each implement them differently, but the core idea is the same: a value that notifies its dependents when it changes. React is the exception — it has no built-in signal primitive. This library brings signals to React with a small, framework-agnostic core and a thin React bridge.

<Callout>
This page explains the design decisions behind `@owanturist/signal`'s API by showing how other frameworks solve the same problems. It is not a feature comparison — each framework has its own strengths, ecosystem, and maturity.
</Callout>

## Creating Signals

Every signal library starts with the same question: how do you create a reactive value?

```ts title="@owanturist/signal"
import { Signal } from "@owanturist/signal"

const count = Signal(0)
const doubled = Signal((monitor) => count.read(monitor) * 2)
```

```ts tab="Angular"
import { signal, computed } from "@angular/core"

const count = signal(0)
const doubled = computed(() => count() * 2)
```

```ts tab="Solid"
import { createSignal, createMemo } from "solid-js"

const [count, setCount] = createSignal(0)
const doubled = createMemo(() => count() * 2)
```

```ts tab="Preact"
import { signal, computed } from "@preact/signals-core"

const count = signal(0)
const doubled = computed(() => count.value * 2)
```

```ts tab="Vue"
import { ref, computed } from "vue"

const count = ref(0)
const doubled = computed(() => count.value * 2)
```

```ts tab="Svelte"
let count = $state(0)
let doubled = $derived(count * 2)
```

```ts tab="Qwik"
import { useSignal, useComputed$ } from "@builder.io/qwik"

const count = useSignal(0)
const doubled = useComputed$(() => count.value * 2)
```

A single `Signal()` factory covers all three roles — writable, derived, and bidirectional derived. The first argument determines which kind you get: a plain value creates a writable signal, a function creates a derived one. Most other frameworks use separate functions (`signal` + `computed`, `createSignal` + `createMemo`) — two names for what is conceptually a single operation.

## Reading Values

How do you get the current value out of a signal?

```ts title="@owanturist/signal"
import { Signal } from "@owanturist/signal"

const count = Signal(5)

// Inside a reactive context — pass a monitor
effect((monitor) => {
  console.log(count.read(monitor)) // 5
})

// Outside — read without a monitor
console.log(count.read()) // 5
```

```ts tab="Angular"
const count = signal(5)

console.log(count()) // 5
```

```ts tab="Solid"
const [count, setCount] = createSignal(5)

console.log(count()) // 5
```

```ts tab="Preact"
const count = signal(5)

console.log(count.value) // 5
```

```ts tab="Vue"
const count = ref(5)

console.log(count.value) // 5
```

```ts tab="Svelte"
let count = $state(5)

console.log(count) // 5
```

```ts tab="Qwik"
const count = useSignal(5)

console.log(count.value) // 5
```

Every other framework uses implicit tracking — calling the getter or accessing a property automatically registers the dependency. This library makes tracking explicit through the Monitor parameter — you can always trace a computation's dependencies. The tradeoff is extra syntax in exchange for explicit dependency tracking.

## Writing Values

How do you update a signal?

```ts title="@owanturist/signal"
import { Signal } from "@owanturist/signal"

const count = Signal(0)

count.write(5)
count.write((prev) => prev + 1)
```

```ts tab="Angular"
const count = signal(0)

count.set(5)
count.update((n) => n + 1)
```

```ts tab="Solid"
const [count, setCount] = createSignal(0)

setCount(5)
setCount((prev) => prev + 1)
```

```ts tab="Preact"
const count = signal(0)

count.value = 5
count.value++
```

```ts tab="Vue"
const count = ref(0)

count.value = 5
count.value++
```

```ts tab="Svelte"
let count = $state(0)

count = 5
count++
```

```ts tab="Qwik"
const count = useSignal(0)

count.value = 5
count.value++
```

The `.write()` method handles both direct values and updater functions, keeping reads and writes as deliberate method calls. Frameworks like Preact, Vue, and Qwik use property assignment (`.value = x`), while Svelte makes reactivity look like plain JavaScript. Angular and Solid separate the setter into its own method or function.

## Derived Signals

Derived signals compute a value from other signals and update automatically when their dependencies change.

```ts title="@owanturist/signal"
import { Signal } from "@owanturist/signal"

const firstName = Signal("Morgan")
const lastName = Signal("Freeman")

const fullName = Signal(
  (monitor) => `${firstName.read(monitor)} ${lastName.read(monitor)}`,
)
```

```ts tab="Angular"
import { signal, computed } from "@angular/core"

const firstName = signal("Morgan")
const lastName = signal("Freeman")

const fullName = computed(() => `${firstName()} ${lastName()}`)
```

```ts tab="Solid"
import { createSignal, createMemo } from "solid-js"

const [firstName, setFirstName] = createSignal("Morgan")
const [lastName, setLastName] = createSignal("Freeman")

const fullName = createMemo(() => `${firstName()} ${lastName()}`)
```

```ts tab="Preact"
import { signal, computed } from "@preact/signals-core"

const firstName = signal("Morgan")
const lastName = signal("Freeman")

const fullName = computed(() => `${firstName.value} ${lastName.value}`)
```

```ts tab="Vue"
import { ref, computed } from "vue"

const firstName = ref("Morgan")
const lastName = ref("Freeman")

const fullName = computed(() => `${firstName.value} ${lastName.value}`)
```

```ts tab="Svelte"
let firstName = $state("Morgan")
let lastName = $state("Freeman")

let fullName = $derived(`${firstName} ${lastName}`)
```

```ts tab="Qwik"
import { useSignal, useComputed$ } from "@builder.io/qwik"

const firstName = useSignal("Morgan")
const lastName = useSignal("Freeman")

const fullName = useComputed$(() => `${firstName.value} ${lastName.value}`)
```

All frameworks provide read-only derived signals. The syntax varies, but the goal is identical: declare a computation and the framework keeps it current. `Signal()` is reused here — pass a function as the first argument to create a derived signal.

### Bidirectional Derived Signals

Most frameworks only support read-only derived values. This library and Vue also support bidirectional derived signals — computed values you can write to, propagating changes back to their sources.

```ts title="@owanturist/signal"
import { Signal } from "@owanturist/signal"

const celsius = Signal(0)
const fahrenheit = Signal(
  (monitor) => celsius.read(monitor) * 9 / 5 + 32,
  (value) => celsius.write((value - 32) * 5 / 9),
)

fahrenheit.write(212) // celsius is now 100
```

```ts tab="Vue"
import { ref, computed } from "vue"

const celsius = ref(0)
const fahrenheit = computed({
  get: () => celsius.value * 9 / 5 + 32,
  set: (value) => {
    celsius.value = (value - 32) * 5 / 9
  },
})

fahrenheit.value = 212 // celsius is now 100
```

Angular, Solid, Preact, Svelte, and Qwik do not support bidirectional derived signals. Vue's `computed({ get, set })` directly inspired this library's `Signal(getter, setter)` — both create two-way bindings without manual synchronization.

## Effects

Effects run side effects in response to signal changes.

```ts title="@owanturist/signal"
import { Signal, effect } from "@owanturist/signal"

const count = Signal(0)

const dispose = effect((monitor) => {
  console.log(`Count is ${count.read(monitor)}`)
})
```

```ts tab="Angular"
import { signal, effect } from "@angular/core"

const count = signal(0)

effect(() => {
  console.log(`Count is ${count()}`)
})
```

```ts tab="Solid"
import { createSignal, createEffect } from "solid-js"

const [count, setCount] = createSignal(0)

createEffect(() => {
  console.log(`Count is ${count()}`)
})
```

```ts tab="Preact"
import { signal, effect } from "@preact/signals-core"

const count = signal(0)

const dispose = effect(() => {
  console.log(`Count is ${count.value}`)
})
```

```ts tab="Vue"
import { ref, watchEffect } from "vue"

const count = ref(0)

watchEffect(() => {
  console.log(`Count is ${count.value}`)
})
```

```ts tab="Svelte"
let count = $state(0)

$effect(() => {
  console.log(`Count is ${count}`)
})
```

```ts tab="Qwik"
import { useSignal } from "@builder.io/qwik"

const count = useSignal(0)

useTask$(({ track }) => {
  const value = track(count)
  console.log(`Count is ${value}`)
})
```

Effects run synchronously and return a dispose function, similar to Preact. Angular and Vue schedule effects as microtasks, Solid and Svelte run them after rendering, and Qwik uses explicit `track()` calls inside `useTask$()`. The synchronous approach is predictable — you always know when the effect has run.

## Batching

When you update multiple signals at once, batching prevents intermediate recomputations.

```ts title="@owanturist/signal"
import { Signal, batch } from "@owanturist/signal"

const first = Signal("Jane")
const last = Signal("Doe")

batch(() => {
  first.write("John")
  last.write("Smith")
})
// Dependents recompute only once
```

```ts tab="Angular"
// Angular batches implicitly through
// its change detection mechanism.
// No explicit batch() function.
```

```ts tab="Solid"
import { batch } from "solid-js"

batch(() => {
  setFirst("John")
  setLast("Smith")
})
```

```ts tab="Preact"
import { batch } from "@preact/signals-core"

batch(() => {
  first.value = "John"
  last.value = "Smith"
})
```

```ts tab="Vue"
// Vue batches implicitly through its
// async reactivity scheduler queue.
// No explicit batch() function.
```

```ts tab="Svelte"
// Svelte batches implicitly via
// microtask scheduling.
// No explicit batch() function.
```

```ts tab="Qwik"
// Qwik batches implicitly through its
// async scheduler.
// No explicit batch() function.
```

Angular, Vue, Svelte, and Qwik batch updates implicitly through their schedulers. Solid and Preact offer explicit `batch()` alongside implicit batching in certain contexts. Explicit `batch()` calls are required here because, as a third-party library, it cannot hook into React's scheduler the way framework-native solutions do.

## Custom Equality

Custom equality lets you define when a new value counts as a change.

```ts title="@owanturist/signal"
import { Signal } from "@owanturist/signal"

const data = Signal(["test"], {
  equals: (prev, next) =>
    prev.length === next.length &&
    prev.every((v, i) => v === next[i]),
})

data.write(["test"]) // No update — arrays are equal
```

```ts tab="Angular"
import { signal } from "@angular/core"

const data = signal(["test"], {
  equal: (a, b) =>
    a.length === b.length &&
    a.every((v, i) => v === b[i]),
})

data.set(["test"]) // No update
```

```ts tab="Solid"
import { createSignal } from "solid-js"

const [data, setData] = createSignal(["test"], {
  equals: (prev, next) =>
    prev.length === next.length &&
    prev.every((v, i) => v === next[i]),
})

setData(["test"]) // No update
```

```ts tab="Preact"
// Preact Signals does not support
// custom equality comparisons.
```

```ts tab="Vue"
// Vue does not support custom equality
// comparators for ref() or computed().
```

```ts tab="Svelte"
// Svelte does not support custom
// equality comparisons.
```

```ts tab="Qwik"
// Qwik does not support custom
// equality comparisons.
```

Only Angular, Solid, and this library support custom equality. The default behavior across all frameworks is reference equality (`Object.is`). Custom equality avoids unnecessary recomputations for data that is structurally identical but referentially different, like arrays or objects.

## Nested Signals

Signals holding other signals — nested composition — works seamlessly when signals are plain values.

```ts title="@owanturist/signal"
import { Signal, effect } from "@owanturist/signal"

const items = Signal([
  Signal("first"),
  Signal("second"),
])

effect((monitor) => {
  for (const item of items.read(monitor)) {
    console.log(item.read(monitor))
  }
})

// Adding a new item re-triggers the effect
items.write((prev) => [...prev, Signal("third")])
```

```ts tab="Angular"
const inner = signal(0)
const outer = signal(inner)

// Awkward double-call to read nested value
console.log(outer()())
```

```ts tab="Solid"
const [outer, setOuter] = createSignal(0)
const [inner, setInner] = createSignal(outer())

// Manual synchronization required
setInner(outer())
```

```ts tab="Preact"
const outer = signal(signal(42))

// Chained .value access
console.log(outer.value.value) // 42
```

```ts tab="Vue"
const innerRef = ref(1)
const obj = reactive({ count: innerRef })

// Auto-unwrapped — convenient but implicit
console.log(obj.count) // 1
```

```ts tab="Svelte"
// Svelte uses deep reactive proxies
let todos = $state([
  { done: false, text: "add more todos" },
])

// Mutations are tracked automatically
todos[0].done = true
```

```ts tab="Qwik"
// useStore provides deep reactivity
const state = useStore({
  items: [{ text: "first" }],
})

// Direct mutation is tracked
state.items[0].text = "updated"
```

A `Signal<Array<Signal<string>>>` works naturally because signals are plain values that compose freely. Vue and Svelte solve nesting with deep reactivity proxies — convenient, but it obscures which properties are reactive. Angular and Preact require awkward double-unwrapping. With explicit nesting, you control exactly which level of the hierarchy triggers updates.

## Untracked Reads

Sometimes you need to read a signal without creating a dependency.

```ts title="@owanturist/signal"
import { Signal, effect, untracked } from "@owanturist/signal"

const user = Signal("Alice")
const counter = Signal(0)

effect((monitor) => {
  const name = user.read(monitor)
  const count = untracked(counter)
  console.log(`${name}: ${count}`)
  // Only re-runs when user changes
})
```

```ts tab="Angular"
import { effect, untracked } from "@angular/core"

effect(() => {
  const name = user()
  const count = untracked(counter)
  console.log(`${name}: ${count}`)
})
```

```ts tab="Solid"
import { createEffect } from "solid-js"
import { untrack } from "solid-js"

createEffect(() => {
  const name = user()
  const count = untrack(() => counter())
  console.log(`${name}: ${count}`)
})
```

```ts tab="Preact"
import { effect } from "@preact/signals-core"

effect(() => {
  const name = user.value
  const count = counter.peek()
  console.log(`${name}: ${count}`)
})
```

```ts tab="Vue"
// Vue has no direct equivalent to
// untracked(). You can read .value
// outside of a reactive context or
// use toRaw() for raw object access.
```

```ts tab="Svelte"
$effect(() => {
  const name = user
  const count = untrack(() => counter)
  console.log(`${name}: ${count}`)
})
```

```ts tab="Qwik"
useTask$(({ track }) => {
  const name = track(user)
  const count = untrack(() => otherSignal.value)
  console.log(`${name}: ${count}`)
})
```

Both `untracked(fn)` for arbitrary code and `untracked(signal)` for a single signal are supported — inspired by Angular. Most frameworks offer some form of untracked reads, except Vue which has no direct equivalent. Preact uses `.peek()` on individual signals instead of a global function — though the name doesn't convey "untracked", which can surprise developers who see it return a value without realizing it skips dependency tracking.

## What This Library Does Not Do

This library omits several features found in other signal libraries:

- **No compiler magic** — There is no build step that transforms variable access into reactive subscriptions. Svelte's `$state` and `$derived` runes eliminate boilerplate but require a compiler step. This library runs in any standard JavaScript environment without a build step.

- **No JSX auto-unwrapping** — Preact signals can update the DOM directly from JSX, bypassing component re-renders. This library requires `.read()` calls inside components, though you can build thin wrapper components that accept a signal as a prop and subscribe to it — effectively achieving fine-grained updates scoped to a small subtree.

- **No resumability** — Qwik serializes signals into HTML so the client can resume without hydration. This library targets a standard client-side React environment.

- **No implicit scheduling** — Angular and Vue batch updates implicitly through their change detection and async queue systems. This library requires explicit `batch()` calls when you need to group multiple writes.

- **Immutable data by default** — Signals compare values by reference equality. Mutating an object in place and passing the same reference to `.write()` is a no-op unless you set `equals: () => false`. This matches React's model — `useState`, `useMemo`, props, and context all assume immutability — so signals integrate naturally into React's update model.

Some of these follow from React's constraints; others are deliberate choices favoring explicitness and minimal surface area. Every framework on this page has tackled real problems with approaches worth understanding. This library draws from those approaches and adapts them for React.
