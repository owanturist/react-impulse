---
title: Derived Signals
description: Computing values that automatically stay in sync with their sources
---

Derived signals compute their value from other signals. They use the same Monitor pattern to track dependencies, and they automatically recompute when those dependencies change.

## Creating Derived Signals

Pass a function to `Signal()` instead of a value. The function receives a monitor:

```ts
import { Signal, effect } from "@owanturist/signal"

const count = Signal(0)
const doubled = Signal((monitor) => count.read(monitor) * 2)

effect((monitor) => {
  console.log(doubled.read(monitor)) // 0
})

count.write(5)
// Effect logs: 10
```

## How Derived Signals Use Monitors

A derived signal works just like an effect - it receives a monitor and reads signals through it. This establishes the dependency chain:

```ts
const firstName = Signal("John")
const lastName = Signal("Doe")

// The derived signal's monitor watches firstName and lastName
const fullName = Signal((monitor) => {
  return `${firstName.read(monitor)} ${lastName.read(monitor)}`
})

// When you read fullName, your monitor watches fullName
effect((monitor) => {
  console.log(fullName.read(monitor))
})
```

The flow of notifications:
1. `firstName.write("Jane")` - firstName notifies fullName's monitor
2. fullName marks itself as needing recomputation
3. fullName notifies the effect's monitor
4. The effect re-runs and reads the new fullName value

## Dynamic Dependency Tracking

Just like effects, derived signals track dependencies dynamically based on what gets read:

```ts
const showFullName = Signal(true)
const firstName = Signal("John")
const lastName = Signal("Doe")

const displayName = Signal((monitor) => {
  if (showFullName.read(monitor)) {
    // Dependencies: showFullName, firstName, lastName
    return `${firstName.read(monitor)} ${lastName.read(monitor)}`
  }
  // Dependencies: showFullName, firstName only
  return firstName.read(monitor)
})

showFullName.write(false)
lastName.write("Smith") // Does NOT trigger recomputation
firstName.write("Jane") // Triggers recomputation
```

When `showFullName` becomes `false`, the derived signal no longer reads `lastName`, so changes to it are ignored until `showFullName` becomes `true` again.

## Chaining Derived Signals

Derived signals can depend on other derived signals, forming computation chains:

```ts
const price = Signal(100)
const quantity = Signal(2)
const taxRate = Signal(0.1)

const subtotal = Signal((monitor) => {
  return price.read(monitor) * quantity.read(monitor)
})

const tax = Signal((monitor) => {
  return subtotal.read(monitor) * taxRate.read(monitor)
})

const total = Signal((monitor) => {
  return subtotal.read(monitor) + tax.read(monitor)
})

effect((monitor) => {
  console.log(`Total: $${total.read(monitor)}`) // Total: $220
})

price.write(150)
// Effect logs: Total: $330
```

Each derived signal has its own monitor. When `price` changes:
1. `subtotal` recomputes (it watches `price`)
2. `tax` recomputes (it watches `subtotal`)
3. `total` recomputes (it watches both `subtotal` and `tax`)
4. The effect re-runs (it watches `total`)

## Lazy Evaluation

Derived signals are lazy - they only compute when actually read:

```ts
const count = Signal(0)

const expensive = Signal((monitor) => {
  console.log("Computing...")
  return count.read(monitor) * 2
})

count.write(1)
count.write(2)
count.write(3)
// No "Computing..." logged yet - nobody has read the signal

effect((monitor) => {
  console.log(expensive.read(monitor))
})
// Now it logs: "Computing..." then "6"
```

This means unused derived signals have zero cost. They only do work when their value is needed.

## Memoization

Once computed, the value is cached until dependencies change:

```ts
effect((monitor) => {
  console.log(expensive.read(monitor)) // "Computing..." then 6
  console.log(expensive.read(monitor)) // 6 (no recomputation)
  console.log(expensive.read(monitor)) // 6 (no recomputation)
})
```

Reading the same derived signal multiple times in one execution only computes once.

## Bidirectional Derived Signals

You can create derived signals that can be written to by providing both a getter and setter:

```ts
const celsius = Signal(0)

const fahrenheit = Signal(
  // Getter: compute fahrenheit from celsius
  (monitor) => celsius.read(monitor) * 9/5 + 32,
  // Setter: receives value and monitor (monitor unused here)
  (value, _monitor) => celsius.write((value - 32) * 5/9)
)

effect((monitor) => {
  console.log(`${celsius.read(monitor)}C = ${fahrenheit.read(monitor)}F`)
})
// logs: "0C = 32F"

fahrenheit.write(212)
// logs: "100C = 212F"
```

The setter function receives the new value and a monitor (for reading other signals if needed), and should update the source signals. The getter then recomputes based on the updated sources.

## Custom Equality

Derived signals can use custom equality to prevent unnecessary updates downstream:

```ts
interface User {
  id: number
  name: string
}

const users = Signal<User[]>([
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
])

const names = Signal(
  (monitor) => users.read(monitor).map((u) => u.name),
  {
    equals: (prev, next) =>
      prev.length === next.length &&
      prev.every((name, i) => name === next[i]),
  },
)
```

Even if the `users` array reference changes, if the names are the same, watchers of `names` won't be notified.

## Read-Only by Default

Derived signals without a setter are read-only:

```ts
const count = Signal(0)
const doubled = Signal((monitor) => count.read(monitor) * 2)

// TypeScript error: Property 'write' does not exist
// doubled.write(10)

// To change doubled, update its source:
count.write(5) // doubled is now 10
```

## Summary

Derived signals extend the Monitor pattern to computed values:

- They receive a monitor and read source signals through it
- Dependencies are tracked automatically and dynamically
- They're lazy (computed on demand) and memoized (cached until invalidated)
- They form chains that propagate changes efficiently
- Optional setters enable bidirectional bindings

Think of derived signals as formulas in a spreadsheet - they express relationships between values, and the system keeps everything in sync automatically.

## See Also

<Cards>
  <Card title="Signal API Reference" description="Complete API documentation" href="/docs/api/signal" />
  <Card title="Signals and Monitors" description="Core reactive primitives" href="/docs/concepts/signals" />
  <Card title="Common Patterns" description="Practical usage patterns" href="/docs/guides/common-patterns" />
  <Card title="Performance Optimization" description="Optimization techniques" href="/docs/guides/performance" />
</Cards>
