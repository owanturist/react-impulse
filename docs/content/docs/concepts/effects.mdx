---
title: Effects
description: Running side effects that respond to signal changes
---

Effects are where the Monitor pattern meets the outside world. While signals and derived signals are about managing data, effects are about doing things in response to data changes - updating the DOM, making network requests, logging, and other side effects.

## The Effect-Monitor Connection

When you create an effect, it receives a monitor. This is the same Monitor pattern used throughout the library:

```ts
import { Signal, effect } from "@owanturist/signal"

const count = Signal(0)

effect((monitor) => {
  // Pass the monitor to .read() - this registers the effect as a watcher
  console.log(`Count is: ${count.read(monitor)}`)
})
// Immediately logs: "Count is: 0"

count.write(1)
// The effect re-runs, logs: "Count is: 1"
```

Here's what happens step by step:
1. The effect runs immediately with a fresh monitor
2. `count.read(monitor)` returns the value AND registers this monitor with the signal
3. Later, `count.write(1)` updates the value and notifies all watching monitors
4. The effect's monitor triggers a re-run
5. The effect executes again with a fresh monitor (dependencies are re-tracked)

## Why Effects Exist

Signals and derived signals are pure - they just hold or compute values. But applications need to interact with the outside world:

- Update the DOM
- Save to localStorage
- Send analytics events
- Start or stop timers
- Subscribe to external services

Effects bridge this gap. They let you run impure code in response to signal changes while still benefiting from automatic dependency tracking.

## Stopping Effects

Effects return a stop function:

```ts
const count = Signal(0)

const stop = effect((monitor) => {
  console.log(count.read(monitor))
})
// Logs: 0

count.write(1) // Logs: 1
count.write(2) // Logs: 2

stop() // Disconnect the effect

count.write(3) // Nothing logged - effect is stopped
```

When you call `stop()`, the effect's monitor is unregistered from all signals. Changes no longer trigger re-runs.

## Cleanup Callbacks

Effects can return a cleanup function that runs before each re-execution and when the effect stops:

```ts
const userId = Signal("user-1")

effect((monitor) => {
  const id = userId.read(monitor)
  const subscription = subscribeToUser(id)

  // Cleanup runs:
  // 1. Before re-running (when userId changes)
  // 2. When the effect is stopped
  return () => {
    subscription.unsubscribe()
  }
})
```

This is essential for preventing resource leaks. Without cleanup, changing `userId` would create new subscriptions without closing old ones.

## Dynamic Dependencies

Just like derived signals, effects track dependencies dynamically:

```ts
const a = Signal(1)
const b = Signal(2)
const useB = Signal(true)

effect((monitor) => {
  if (useB.read(monitor)) {
    // Dependencies: useB, a, b
    console.log(a.read(monitor) + b.read(monitor))
  } else {
    // Dependencies: useB, a only
    console.log(a.read(monitor))
  }
})

useB.write(false)
b.write(100) // Effect does NOT re-run - b is no longer watched
a.write(5)   // Effect re-runs
```

The monitor tracks exactly what signals were read on the last run. When `useB` becomes false, the effect no longer reads `b`, so its monitor is unregistered from `b`.

## Reading Without Tracking

Use `untracked` to read a signal without establishing a dependency:

```ts
import { Signal, effect, untracked } from "@owanturist/signal"

const count = Signal(0)
const multiplier = Signal(2)

effect((monitor) => {
  // count is tracked
  // multiplier is NOT tracked (using the shorthand form)
  const result = count.read(monitor) * untracked(multiplier)
  console.log(result)
})

count.write(5)       // Effect runs, logs: 10
multiplier.write(3)  // Effect does NOT run
count.write(5)       // Effect runs, logs: 15 (uses current multiplier value)
```

The effect ignores changes to `multiplier`, but still uses its current value when `count` triggers a re-run.

## Batching Multiple Updates

When you update multiple signals, you might want effects to run once after all updates rather than after each one. Use `batch`:

```ts
import { Signal, effect, batch } from "@owanturist/signal"

const firstName = Signal("John")
const lastName = Signal("Doe")

effect((monitor) => {
  console.log(`${firstName.read(monitor)} ${lastName.read(monitor)}`)
})
// Logs: "John Doe"

batch(() => {
  firstName.write("Jane")
  lastName.write("Smith")
})
// Logs once: "Jane Smith"
```

Without batching, the effect would run twice - once for each signal update. With batching, all updates are collected and effects run once at the end.

## Avoiding Infinite Loops

Be careful not to write to signals that the effect reads:

```ts
// DANGER: Infinite loop!
const count = Signal(0)

effect((monitor) => {
  count.write(count.read(monitor) + 1)
})
```

The effect reads `count`, then writes to it, which triggers the effect again, forever.

If you need to update one signal based on another, use separate signals:

```ts
// Safe: reading and writing different signals
const source = Signal(0)
const derived = Signal(0)

effect((monitor) => {
  derived.write(source.read(monitor) * 2)
})

source.write(5) // derived becomes 10
```

Or better yet, use a derived signal instead of an effect.

## Effects vs Derived Signals

Choose the right tool for the job:

| Use Case | Tool |
|----------|------|
| Computing a value from other signals | Derived signal |
| Transforming or filtering data | Derived signal |
| Side effects (DOM, network, logging) | Effect |
| Syncing with external systems | Effect |

```ts
// Derived signal: computing a value
const total = Signal((monitor) => {
  return price.read(monitor) * quantity.read(monitor)
})

// Effect: doing something with that value
effect((monitor) => {
  analytics.track("cart_updated", { total: total.read(monitor) })
})
```

Effects are for actions. Derived signals are for values.

## Summary

Effects complete the reactive picture:

- They receive a monitor just like derived signals
- Dependencies are tracked automatically through `.read(monitor)`
- They re-run when watched signals change
- Cleanup functions prevent resource leaks
- Batching prevents excessive re-runs

The Monitor is the thread that connects everything - signals know who is reading them, and can notify exactly the right effects and derived signals when values change.

## See Also

- [effect API Reference](/docs/api/effect) - Complete API documentation
- [Signals and Monitors](/docs/concepts/signals) - Core reactive primitives
- [Resource Cleanup](/docs/guides/cleanup) - Cleanup patterns in detail
- [Batching Updates](/docs/guides/batching) - Batching guide
