---
title: untracked
description: API reference for the untracked function
---

# untracked

The `untracked` function reads signal values without creating reactive dependencies.

## Function Signatures

```ts
function untracked<TResult>(factory: (monitor: Monitor) => TResult): TResult
function untracked<TValue>(signal: ReadableSignal<TValue>): TValue
```

## Parameters

### Factory Form

| Parameter | Type | Description |
|-----------|------|-------------|
| `factory` | `(monitor: Monitor) => TResult` | Function to execute without tracking. Receives an untracked Monitor. |

### Signal Form

| Parameter | Type | Description |
|-----------|------|-------------|
| `signal` | `ReadableSignal<TValue>` | Signal to read without tracking |

## Returns

Returns the value from the factory or signal.

## Examples

### Basic Usage

```ts
import { Signal, effect, untracked } from "@owanturist/signal"

const count = Signal(0)
const multiplier = Signal(2)

effect((monitor) => {
  // count is tracked
  // multiplier is NOT tracked
  const result = count.read(monitor) * untracked((m) => multiplier.read(m))
  console.log(result)
})
// Logs: 0

count.write(5)
// Logs: 10

multiplier.write(3)
// Nothing logged (multiplier not tracked)

count.write(5)
// Logs: 15 (uses current multiplier value)
```

### Signal Shorthand

```ts
const count = Signal(0)
const config = Signal({ multiplier: 2 })

effect((monitor) => {
  // Equivalent to: untracked((m) => config.read(m))
  const { multiplier } = untracked(config)
  console.log(count.read(monitor) * multiplier)
})
```

### In Derived Signals

```ts
const items = Signal([1, 2, 3])
const sortOrder = Signal<"asc" | "desc">("asc")

// Only re-computes when items change, not when sortOrder changes
const sortedItems = Signal((monitor) => {
  const order = untracked((m) => sortOrder.read(m))
  const arr = [...items.read(monitor)]

  return order === "asc"
    ? arr.sort((a, b) => a - b)
    : arr.sort((a, b) => b - a)
})
```

## Use Cases

### Configuration Values

Read configuration that shouldn't trigger re-runs:

```ts
const data = Signal<Item[]>([])
const pageSize = Signal(10)

effect((monitor) => {
  // Re-run when data changes, not when pageSize changes
  const size = untracked((m) => pageSize.read(m))
  displayItems(data.read(monitor).slice(0, size))
})
```

### Logging and Debugging

```ts
const requestId = Signal(0)
const response = Signal<Response | null>(null)

effect((monitor) => {
  const res = response.read(monitor)
  if (res) {
    // Don't track requestId - just for logging
    console.log(`Request ${untracked(requestId)} completed:`, res)
  }
})
```

### Conditional Dependencies

```ts
const mode = Signal<"simple" | "advanced">("simple")
const basicConfig = Signal({ threshold: 10 })
const advancedConfig = Signal({ threshold: 5, precision: 2 })

effect((monitor) => {
  // Always track mode
  if (mode.read(monitor) === "simple") {
    // Only track basicConfig in simple mode
    process(basicConfig.read(monitor))
  } else {
    // Only track advancedConfig in advanced mode
    process(advancedConfig.read(monitor))
  }
})
```

### Avoiding Unnecessary Re-renders

```ts
const items = Signal<Item[]>([])
const selectedId = Signal<string | null>(null)

// This derived signal only updates when items change
const itemsWithSelection = Signal((monitor) => {
  const selected = untracked((m) => selectedId.read(m))
  return items.read(monitor).map((item) => ({
    ...item,
    isSelected: item.id === selected,
  }))
})

// To get current selection state, read both:
effect((monitor) => {
  const currentItems = items.read(monitor)
  const currentSelection = selectedId.read(monitor)
  render(currentItems, currentSelection)
})
```

### One-Time Reads

```ts
const initialValue = Signal(100)
const currentValue = Signal(0)

effect((monitor) => {
  // Read initial value once (on first run only)
  const initial = untracked((m) => initialValue.read(m))
  const current = currentValue.read(monitor)

  console.log(`Changed by ${current - initial}`)
})
```

## Nested Untracked

Untracked calls can be nested:

```ts
const a = Signal(1)
const b = Signal(2)
const c = Signal(3)

effect((monitor) => {
  const aVal = a.read(monitor) // tracked

  const result = untracked((m) => {
    const bVal = b.read(m) // not tracked
    const cVal = untracked((m2) => c.read(m2)) // also not tracked
    return bVal + cVal
  })

  console.log(aVal + result)
})

a.write(10) // Effect re-runs
b.write(20) // No re-run
c.write(30) // No re-run
```

## Common Mistakes

### Tracking Still Happens Outside untracked

```ts
const a = Signal(1)
const b = Signal(2)

effect((monitor) => {
  const aVal = a.read(monitor) // This IS tracked!
  const bVal = untracked((m) => b.read(m)) // This is not tracked
  console.log(aVal + bVal)
})
```

### Stale Values

Since untracked values aren't dependencies, they can become stale:

```ts
const count = Signal(0)
const label = Signal("Count")

effect((monitor) => {
  // label might be stale
  const lbl = untracked((m) => label.read(m))
  console.log(`${lbl}: ${count.read(monitor)}`)
})

label.write("Value") // Effect doesn't re-run
count.write(1) // Logs: "Value: 1" (label was updated)
```

## See Also

- [Signals](/docs/concepts/signals)
- [Effects](/docs/concepts/effects)
- [effect()](/docs/api/effect)
- [batch()](/docs/api/batch)
