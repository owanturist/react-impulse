---
title: untracked
description: API reference for the untracked function
---

The `untracked` function reads signal values without creating reactive dependencies.

## `untracked(factory){:dart}` [#factory]

```ts
function untracked<TResult>(factory: (monitor: Monitor) => TResult): TResult
```

Executes a function with an untracked Monitor, allowing signal reads that don't establish dependencies.

<section className="typedef">

- `@param factory: (monitor: Monitor) => TResult{:dart}` Function to execute without tracking. Receives an untracked Monitor.

---

- `@returns TResult{:dart}` The return value of the factory function.

</section>

```ts twoslash tab="Example"
import { Signal, effect, untracked } from "@owanturist/signal"

const count = Signal(0)
const multiplier = Signal(2)

effect((monitor) => {
  // count is tracked
  // multiplier is NOT tracked
  const result = count.read(monitor) * untracked((m) => multiplier.read(m))
  console.log(result)
})
// Logs: 0

count.write(5)
// Logs: 10

multiplier.write(3)
// Nothing logged (multiplier not tracked)

count.write(5)
// Logs: 15 (uses current multiplier value)
```

## `untracked(signal){:dart}` [#signal]

```ts
function untracked<TValue>(signal: ReadableSignal<TValue>): TValue
```

Reads a signal's value without establishing a dependency. Shorthand for `untracked((m) => signal.read(m)){:ts}`.

<section className="typedef">

- `@param signal: ReadableSignal<TValue>{:dart}` Signal to read without tracking.

---

- `@returns TValue{:dart}` The current value of the signal.

</section>

```ts twoslash tab="Example"
import { Signal, effect, untracked } from "@owanturist/signal"

const count = Signal(0)
const config = Signal({ multiplier: 2 })

effect((monitor) => {
  const { multiplier } = untracked(config)
  console.log(count.read(monitor) * multiplier)
})
```

```ts twoslash tab="In Derived"
import { Signal, untracked } from "@owanturist/signal"

const items = Signal([1, 2, 3])
const sortOrder = Signal<"asc" | "desc">("asc")

// Only re-computes when items change, not when sortOrder changes
const sortedItems = Signal((monitor) => {
  const order = untracked((m) => sortOrder.read(m))
  const arr = [...items.read(monitor)]

  return order === "asc" ? arr.sort((a, b) => a - b) : arr.sort((a, b) => b - a)
})
```

## Nested Untracked

Untracked calls can be nested:

```ts twoslash
import { Signal, effect, untracked } from "@owanturist/signal"

const a = Signal(1)
const b = Signal(2)
const c = Signal(3)

effect((monitor) => {
  const aVal = a.read(monitor) // tracked

  const result = untracked((m) => {
    const bVal = b.read(m) // not tracked
    const cVal = untracked((m2) => c.read(m2)) // also not tracked
    return bVal + cVal
  })

  console.log(aVal + result)
})

a.write(10) // Effect re-runs
b.write(20) // No re-run
c.write(30) // No re-run
```

## Common Mistakes

### Tracking Still Happens Outside untracked

Reads outside the `untracked` call are still tracked:

```ts twoslash
import { Signal, effect, untracked } from "@owanturist/signal"

const a = Signal(1)
const b = Signal(2)

effect((monitor) => {
  const aVal = a.read(monitor) // This IS tracked
  const bVal = untracked((m) => b.read(m)) // This is not tracked
  console.log(aVal + bVal)
})
```

### Stale Values

Since untracked values aren't dependencies, they can become stale:

```ts twoslash
import { Signal, effect, untracked } from "@owanturist/signal"

const count = Signal(0)
const label = Signal("Count")

effect((monitor) => {
  // label might be stale
  const lbl = untracked((m) => label.read(m))
  console.log(`${lbl}: ${count.read(monitor)}`)
})

label.write("Value") // Effect doesn't re-run
count.write(1) // Logs: "Value: 1" (label was updated)
```

## See Also

- [Signals and Monitors](/docs/concepts/signals) - Core concepts
- [Effects](/docs/concepts/effects) - Effect fundamentals
- [batch](/docs/api/batch) - Batching updates
