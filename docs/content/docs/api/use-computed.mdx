---
title: useComputed
description: API reference for the useComputed hook
---

The `useComputed` hook reads signal values in React components and triggers re-renders when those values change.

## `useComputed(signal){:dart}` [#signal-shortcut]

```ts
function useComputed<TValue>(signal: ReadableSignal<TValue>): TValue
```

Reads a signal's value and subscribes the component to changes.

<section className="typedef">

- `@param signal: ReadableSignal<TValue>{:dart}` A signal to read from.

---

- `@returns TValue{:dart}` The current value of the signal.

</section>

```tsx tab="Example"
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"

const count = Signal(0)

function Counter() {
  const value = useComputed(count)

  return <div>Count: {value}</div>
}
```

## `useComputed(compute, dependencies?, options?){:dart}` [#factory]

```ts
function useComputed<TResult>(
  compute: (monitor: Monitor) => TResult,
  dependencies?: DependencyList,
  options?: UseComputedOptions<TResult>,
): TResult
```

Executes a compute function that can read multiple signals and subscribes the component to all signals read within the function.

<section className="typedef">

- `@param compute: (monitor: Monitor) => TResult{:dart}` A function that receives a Monitor and returns a computed value. All signals read via `signal.read(monitor){:ts}` inside this function become dependencies.

- `@param dependencies?: DependencyList{:dart}` Optional array of React dependencies. When provided, the compute function is memoized and only recreated when dependencies change. When omitted, the compute function runs on every render.

  <Callout>
    For stable compute functions that don't depend on React props or state, pass an empty array `[]{:ts}` to prevent unnecessary recreations.
  </Callout>

- `@param options?.equals?: null | Equal<TResult>{:dart}` Custom equality function to determine if the computed result has changed. Defaults to `Object.is{:ts}`. Pass `null{:ts}` to use the default.

---

- `@returns TResult{:dart}` The result of the compute function.

</section>

```tsx tab="Basic"
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"

const firstName = Signal("John")
const lastName = Signal("Doe")

function FullName() {
  const fullName = useComputed((monitor) => {
    return `${firstName.read(monitor)} ${lastName.read(monitor)}`
  }, [])

  return <div>{fullName}</div>
}
```

```tsx tab="With Props"
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"

const items = Signal<string[]>([])

function FilteredList({ filter }: { filter: string }) {
  const filtered = useComputed(
    (monitor) => {
      return items.read(monitor).filter((item) => item.includes(filter))
    },
    [filter], // Recreate when filter prop changes
  )

  return (
    <ul>
      {filtered.map((item, i) => (
        <li key={i}>{item}</li>
      ))}
    </ul>
  )
}
```

```tsx tab="Custom Equality"
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"

interface Position {
  x: number
  y: number
}

const position = Signal<Position>({ x: 0, y: 0 })

function Cursor() {
  const pos = useComputed((monitor) => position.read(monitor), [], {
    equals: (a, b) => a.x === b.x && a.y === b.y,
  })

  return (
    <div
      style={{
        position: "absolute",
        left: pos.x,
        top: pos.y,
      }}
    />
  )
}
```

## `UseComputedOptions<TValue>{:dart}` [#options]

```ts
interface UseComputedOptions<TValue> {
  readonly equals?: null | Equal<TValue>
}

type Equal<T> = (left: T, right: T) => boolean
```

<section className="typedef">

- `@param equals?: null | Equal<TValue>{:dart}` Custom equality function to compare the previous and next computed values. When the function returns `true{:ts}`, the component does not re-render. Defaults to `Object.is{:ts}`.

</section>

## `DependencyList{:dart}` [#dependency-list]

```ts
type DependencyList = ReadonlyArray<unknown>
```

Standard React dependency array type. The compute function is memoized and only recreated when values in this array change (compared by reference).

## Creating Signals Inside Components [#creating-signals]

Signals hold state and must be stored in permanent storage such as `useState{:ts}` (ignoring the setter) or `useRef{:ts}`:


```tsx tab="Good"
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"
import { useState, useRef } from "react"

// Permanent storage via useState (setter is unused)
function GoodCounter() {
  const [count] = useState(() => Signal(0))
  const value = useComputed(count)
  return <div>{value}</div>
}

// Also good: Permanent storage via useRef
function AlsoGoodCounter() {
  const { current: count } = useRef(Signal(0))
  const value = useComputed(count)
  return <div>{value}</div>
}
```

```tsx tab="Bad"
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"

// Creates new signal on every render
function BadCounter() {
  const count = Signal(0) // New signal every render!
  const value = useComputed(count)
  return <div>{value}</div>
}
```

Derived signals are different — they don't store state, so `useMemo{:ts}` is the right choice:

```tsx
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"
import { useState, useMemo } from "react"

function DoubleCounter() {
  const [count] = useState(() => Signal(0))
  const doubled = useMemo(() => Signal((monitor) => count.read(monitor) * 2), [count])
  const value = useComputed(doubled)
  return <div>{value}</div>
}
```

## Optimizing with Dependency Arrays [#dependency-arrays]

The dependency array controls when the compute function is *executed*. Without a dependency array, the compute function executes on every re-render. When a dependency array is provided, the compute function only re-executes when one of the listed dependencies changes.

<Callout>
  The `useComputed` hook should be configured as a target for the exhaustive dependencies lint rule in your project. In Biome, add it to the [`useExhaustiveDependencies`](https://biomejs.dev/linter/rules/use-exhaustive-dependencies/) hooks option. In ESLint, use the `additionalHooks` option of [`react-hooks/exhaustive-deps`](https://react.dev/reference/eslint-plugin-react-hooks/lints/exhaustive-deps). When configured, signals referenced in the compute function must be listed in the dependency array — just like props and state in native React hooks.
</Callout>

```tsx
import { Signal } from "@owanturist/signal"
import { useComputed } from "@owanturist/signal-react"
import { useState } from "react"

function ItemCount() {
  const [data] = useState(() => Signal<string[]>([]))

  // Executes on every re-render (no dependency array)
  const items = useComputed((monitor) => data.read(monitor))

  // Only re-executes when `data` reference changes
  const items = useComputed((monitor) => data.read(monitor), [data])

  const items = useComputed(data) // Shortcut for the above

  return <div>{items.length}</div>
}
```

## See Also

<Cards>
  <Card title="React Integration" description="How signals work with React" href="/docs/concepts/react-integration" />
</Cards>
