---
title: MonitorFactory
description: API reference for the MonitorFactory class
---

`MonitorFactory` is an advanced API for creating custom monitors that track signal dependencies. This is primarily used for building framework integrations.

## Import

```ts
import { MonitorFactory } from "@owanturist/signal/monitor-factory"
```

<Callout>
  `MonitorFactory` is exported from a separate entrypoint, not the main package.
</Callout>

## `new MonitorFactory(){:dart}` [#constructor]

```ts
class MonitorFactory {
  constructor()
}
```

Creates a new MonitorFactory instance.

## `factory.create{:dart}` [#create]

```ts
public get create(): () => Monitor
```

Returns a factory function that creates new Monitor instances for tracking signal reads.

<section className="typedef">

- `@returns () => Monitor{:dart}` A function that creates fresh Monitor instances.

</section>

## `factory.connect(emit){:dart}` [#connect]

```ts
public connect(emit: VoidFunction): VoidFunction
```

Registers an emission callback that will be invoked when any tracked signal changes.

<section className="typedef">

- `@param emit: VoidFunction{:dart}` Callback invoked when any tracked signal changes.

---

- `@returns VoidFunction{:dart}` A cleanup function that invalidates the underlying emitter when invoked.

</section>

## `Monitor{:dart}` [#monitor]

```ts
interface Monitor {
  // Opaque type used internally by signals
}
```

The `Monitor` type is opaque. You pass it to `signal.read(monitor)` to track dependencies.

## Examples

```ts twoslash tab="Basic"
import { Signal } from "@owanturist/signal"
import { MonitorFactory } from "@owanturist/signal/monitor-factory"

const count = Signal(0)

const factory = new MonitorFactory()

const disconnect = factory.connect(() => {
  console.log("A tracked signal changed!")
})

const monitor = factory.create()
const value = count.read(monitor)

console.log(value) // 0

count.write(1)
// Logs: "A tracked signal changed!"

disconnect()

count.write(2)
// Nothing logged (disconnected)
```

```tsx twoslash tab="React Hook"
// @noErrors
import { useCallback, useMemo, useSyncExternalStore } from "react"
import type { Monitor } from "@owanturist/signal"
import { MonitorFactory } from "@owanturist/signal/monitor-factory"

function useSignalValue<T>(compute: (monitor: Monitor) => T): T {
  const store = useMemo(() => {
    let currentValue: T
    let factory: MonitorFactory | null = null
    const listeners = new Set<() => void>()

    const subscribe = (listener: () => void) => {
      listeners.add(listener)
      return () => listeners.delete(listener)
    }

    const getSnapshot = () => {
      if (factory === null) {
        factory = new MonitorFactory()
        factory.connect(() => {
          const monitor = factory!.create()
          currentValue = compute(monitor)
          listeners.forEach((l) => l())
        })
      }

      const monitor = factory.create()
      currentValue = compute(monitor)
      return currentValue
    }

    return { subscribe, getSnapshot }
  }, [compute])

  return useSyncExternalStore(store.subscribe, store.getSnapshot)
}
```

```ts twoslash tab="Multiple Monitors"
import { Signal } from "@owanturist/signal"
import { MonitorFactory } from "@owanturist/signal/monitor-factory"

const a = Signal(1)
const b = Signal(2)

const factory = new MonitorFactory()
const disconnect = factory.connect(() => {
  console.log("Changed!")
})

const monitor1 = factory.create()
a.read(monitor1)

const monitor2 = factory.create()
b.read(monitor2)

// Both a and b are now tracked
a.write(10) // Logs: "Changed!"
b.write(20) // Logs: "Changed!"

disconnect()
```

```ts twoslash tab="Custom Watcher"
import type { Monitor } from "@owanturist/signal"
import { Signal } from "@owanturist/signal"
import { MonitorFactory } from "@owanturist/signal/monitor-factory"

function createWatcher<T>(
  compute: (monitor: Monitor) => T,
  callback: (value: T) => void,
): () => void {
  const factory = new MonitorFactory()

  const disconnect = factory.connect(() => {
    const monitor = factory.create()
    const value = compute(monitor)
    callback(value)
  })

  // Initial run
  const monitor = factory.create()
  const value = compute(monitor)
  callback(value)

  return disconnect
}

const count = Signal(0)
const stop = createWatcher(
  (monitor) => count.read(monitor) * 2,
  (doubled) => console.log("Doubled:", doubled),
)
// Logs: "Doubled: 0"

count.write(5)
// Logs: "Doubled: 10"

stop()
```

## Important Notes

1. **Memory management** - Always call the disconnect function returned by `connect()` when the factory is no longer needed
2. **Single callback** - One factory has one `connect` callback for all tracked signals
3. **Synchronous** - The `emit` callback is invoked synchronously when signals change
4. **Advanced API** - Most users should use `effect()` or framework-specific hooks instead

## See Also

<Cards>
  <Card title="effect" description="High-level effect API" href="/docs/api/effect" />
  <Card title="useMonitor" description="React hook for monitor access" href="/docs/api/use-monitor" />
  <Card title="Signals and Monitors" description="Core concepts" href="/docs/concepts/signals" />
</Cards>
