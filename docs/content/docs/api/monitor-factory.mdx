---
title: MonitorFactory
description: API reference for the MonitorFactory class
---

# MonitorFactory

`MonitorFactory` is an advanced API for creating custom monitors that track signal dependencies. This is primarily used for building framework integrations.

## Import

```ts
import { MonitorFactory } from "@owanturist/signal/monitor-factory"
```

Note: `MonitorFactory` is exported from a separate entrypoint, not the main package.

## Class Definition

```ts
class MonitorFactory {
  public get create(): () => Monitor
  public connect(emit: VoidFunction): VoidFunction
}
```

## Constructor

```ts
new MonitorFactory()
```

The constructor takes no parameters.

## Methods

### create (getter)

```ts
public get create(): () => Monitor
```

Returns a factory function that creates new `Monitor` instances for tracking signal reads.

**Returns:** A function `() => Monitor` that creates fresh Monitor instances.

### connect(emit)

```ts
public connect(emit: VoidFunction): VoidFunction
```

Registers an emission callback that will be invoked when any tracked signal changes.

| Parameter | Type | Description |
|-----------|------|-------------|
| `emit` | `VoidFunction` | Callback invoked when any tracked signal changes |

**Returns:** A cleanup function that invalidates the underlying emitter when invoked.

## Monitor Interface

```ts
interface Monitor {
  // Internal interface used by signals
}
```

The `Monitor` type is opaque - you pass it to `signal.read()` to track dependencies.

## Examples

### Basic Usage

```ts
import { Signal } from "@owanturist/signal"
import { MonitorFactory } from "@owanturist/signal/monitor-factory"

const count = Signal(0)

const factory = new MonitorFactory()

// Connect a callback to be notified of changes
const disconnect = factory.connect(() => {
  console.log("A tracked signal changed!")
})

// Create a monitor and track reads
const monitor = factory.create()
const value = count.read(monitor)

console.log(value) // 0

count.write(1)
// Logs: "A tracked signal changed!"

// Clean up when done
disconnect()

count.write(2)
// Nothing logged (disconnected)
```

### Building a Custom Hook

Here's how you might use `MonitorFactory` to build a React hook:

```tsx
import { useCallback, useMemo, useSyncExternalStore } from "react"
import { MonitorFactory } from "@owanturist/signal/monitor-factory"

function useSignalValue<T>(compute: (monitor: Monitor) => T): T {
  const store = useMemo(() => {
    let currentValue: T
    let factory: MonitorFactory | null = null
    const listeners = new Set<() => void>()

    const subscribe = (listener: () => void) => {
      listeners.add(listener)
      return () => listeners.delete(listener)
    }

    const getSnapshot = () => {
      if (factory === null) {
        factory = new MonitorFactory()
        factory.connect(() => {
          // Re-compute and notify listeners
          const monitor = factory!.create()
          currentValue = compute(monitor)
          listeners.forEach((l) => l())
        })
      }

      const monitor = factory.create()
      currentValue = compute(monitor)
      return currentValue
    }

    return { subscribe, getSnapshot }
  }, [compute])

  return useSyncExternalStore(store.subscribe, store.getSnapshot)
}
```

### Multiple Monitors

A single factory can create multiple monitors for different tracking scopes:

```ts
const a = Signal(1)
const b = Signal(2)

const factory = new MonitorFactory()
const disconnect = factory.connect(() => {
  console.log("Changed!")
})

// First read scope
const monitor1 = factory.create()
a.read(monitor1)

// Second read scope
const monitor2 = factory.create()
b.read(monitor2)

// Both a and b are now tracked
a.write(10) // Logs: "Changed!"
b.write(20) // Logs: "Changed!"

disconnect()
```

## Use Cases

### Framework Integration

`MonitorFactory` is the building block for integrating signals with UI frameworks:

- React hooks (`useComputed`, `useMonitor`)
- Vue composables
- Svelte stores
- Custom rendering systems

### Custom Reactive Systems

Build custom reactive primitives:

```ts
function createWatcher<T>(
  compute: (monitor: Monitor) => T,
  callback: (value: T) => void
): () => void {
  const factory = new MonitorFactory()

  const disconnect = factory.connect(() => {
    const monitor = factory.create()
    const value = compute(monitor)
    callback(value)
  })

  // Initial run
  const monitor = factory.create()
  const value = compute(monitor)
  callback(value)

  // Return cleanup function
  return disconnect
}

// Usage
const count = Signal(0)
const stop = createWatcher(
  (monitor) => count.read(monitor) * 2,
  (doubled) => console.log("Doubled:", doubled)
)
// Logs: "Doubled: 0"

count.write(5)
// Logs: "Doubled: 10"

stop()
```

### Testing

Useful for testing signal reactivity:

```ts
function trackDependencies<T>(compute: (monitor: Monitor) => T): {
  value: T
  changeCount: number
  disconnect: () => void
} {
  let changeCount = 0

  const factory = new MonitorFactory()
  const disconnect = factory.connect(() => {
    changeCount++
  })

  const monitor = factory.create()
  const value = compute(monitor)

  return {
    value,
    get changeCount() {
      return changeCount
    },
    disconnect,
  }
}
```

## Important Notes

1. **Memory management**: Always call the disconnect function returned by `connect()` when the factory is no longer needed
2. **Single callback**: One factory has one `connect` callback for all tracked signals
3. **Synchronous**: The `emit` callback is invoked synchronously when signals change
4. **Advanced API**: Most users should use `effect()` or framework-specific hooks instead

## See Also

- [effect()](/docs/api/effect)
- [Signals](/docs/concepts/signals)
