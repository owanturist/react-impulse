---
title: batch
description: API reference for the batch function
---

# batch

The `batch` function groups multiple signal updates into a single notification, preventing unnecessary intermediate re-renders.

## Function Signature

```ts
function batch(execute: (monitor: Monitor) => void): void
```

## Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `execute` | `(monitor: Monitor) => void` | Function containing signal updates to batch. Receives an untracked Monitor. |

## Returns

Returns `void`. Use `untracked()` if you need to return a value.

## Examples

### Basic Usage

```ts
import { Signal, batch, effect } from "@owanturist/signal"

const firstName = Signal("John")
const lastName = Signal("Doe")

effect((monitor) => {
  console.log(`${firstName.read(monitor)} ${lastName.read(monitor)}`)
})
// Logs: "John Doe"

// Without batch: 2 updates, 2 effect runs
firstName.write("Jane")
// Logs: "Jane Doe"
lastName.write("Smith")
// Logs: "Jane Smith"

// With batch: 2 updates, 1 effect run
batch(() => {
  firstName.write("Bob")
  lastName.write("Wilson")
})
// Logs once: "Bob Wilson"
```

### Reading Values During Batch

The `batch` callback receives an untracked Monitor for reading values:

```ts
import { Signal, batch } from "@owanturist/signal"

const count = Signal(0)

batch((monitor) => {
  // Read current value without tracking
  const current = count.read(monitor)
  count.write(current + 1)
})
```

### Nested Batches

Batches can be nested. Updates are deferred until the outermost batch completes:

```ts
import { Signal, batch, effect } from "@owanturist/signal"

const a = Signal(0)
const b = Signal(0)

effect((monitor) => {
  console.log(`a=${a.read(monitor)}, b=${b.read(monitor)}`)
})
// Logs: "a=0, b=0"

batch(() => {
  a.write(1)

  batch(() => {
    b.write(1)
  })
  // Inner batch completes, but still inside outer batch

  a.write(2)
})
// Logs once: "a=2, b=1"
```

### With Derived Signals

Derived signals are updated after all batched changes:

```ts
import { Signal, batch, effect } from "@owanturist/signal"

const price = Signal(100)
const quantity = Signal(1)
const total = Signal((monitor) => price.read(monitor) * quantity.read(monitor))

effect((monitor) => {
  console.log(total.read(monitor))
})
// Logs: 100

batch(() => {
  price.write(200)
  quantity.write(3)
})
// Logs: 600 (not 200 or 300)
```

## When to Use batch

### Updating Related State

```ts
interface User {
  firstName: string
  lastName: string
  email: string
}

const firstName = Signal("")
const lastName = Signal("")
const email = Signal("")

function updateUser(user: User) {
  batch(() => {
    firstName.write(user.firstName)
    lastName.write(user.lastName)
    email.write(user.email)
  })
}
```

### Form Resets

```ts
const name = Signal("")
const email = Signal("")
const message = Signal("")
const errors = Signal<string[]>([])

function resetForm() {
  batch(() => {
    name.write("")
    email.write("")
    message.write("")
    errors.write([])
  })
}
```

### State Machines

```ts
type Status = "idle" | "loading" | "success" | "error"

const status = Signal<Status>("idle")
const data = Signal<Data | null>(null)
const error = Signal<Error | null>(null)

async function fetchData() {
  batch(() => {
    status.write("loading")
    data.write(null)
    error.write(null)
  })

  try {
    const result = await api.getData()
    batch(() => {
      status.write("success")
      data.write(result)
    })
  } catch (e) {
    batch(() => {
      status.write("error")
      error.write(e as Error)
    })
  }
}
```

## Performance Considerations

Batch is useful when:

1. **Multiple signals update together** - Prevents intermediate states from triggering effects
2. **Updates are logically related** - Keeps state consistent
3. **Performance is critical** - Reduces the number of effect executions

Batch is NOT necessary when:

1. Updating a single signal
2. Updates are independent and don't need to be atomic
3. You want intermediate states to be observable

## See Also

- [Signals](/docs/concepts/signals)
- [Effects](/docs/concepts/effects)
- [effect()](/docs/api/effect)
- [untracked()](/docs/api/untracked)
