---
title: batch
description: API reference for the batch function
---

# batch

The `batch` function groups multiple signal updates into a single notification, preventing unnecessary intermediate re-renders.

## Function Signature

```ts
function batch<T>(fn: () => T): T;
```

## Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `fn` | `() => T` | Function containing signal updates to batch |

## Returns

Returns the value returned by the callback function.

## Examples

### Basic Usage

```ts
import { Signal, batch, effect } from "@owanturist/signal";

const firstName = Signal("John");
const lastName = Signal("Doe");

effect(() => {
  console.log(`${firstName.get()} ${lastName.get()}`);
});
// Logs: "John Doe"

// Without batch: 2 updates, 2 effect runs
firstName.set("Jane");
// Logs: "Jane Doe"
lastName.set("Smith");
// Logs: "Jane Smith"

// With batch: 2 updates, 1 effect run
batch(() => {
  firstName.set("Bob");
  lastName.set("Wilson");
});
// Logs once: "Bob Wilson"
```

### Returning Values

```ts
import { Signal, batch } from "@owanturist/signal";

const count = Signal(0);

const result = batch(() => {
  count.set(1);
  count.set(2);
  count.set(3);
  return count.get();
});

console.log(result); // 3
```

### Nested Batches

Batches can be nested. Updates are deferred until the outermost batch completes:

```ts
import { Signal, batch, effect } from "@owanturist/signal";

const a = Signal(0);
const b = Signal(0);

effect(() => {
  console.log(`a=${a.get()}, b=${b.get()}`);
});
// Logs: "a=0, b=0"

batch(() => {
  a.set(1);

  batch(() => {
    b.set(1);
  });
  // Inner batch completes, but still inside outer batch

  a.set(2);
});
// Logs once: "a=2, b=1"
```

### With Derived Signals

Derived signals are updated after all batched changes:

```ts
import { Signal, batch } from "@owanturist/signal";

const price = Signal(100);
const quantity = Signal(1);
const total = Signal.derive(() => price.get() * quantity.get());

console.log(total.get()); // 100

batch(() => {
  price.set(200);
  quantity.set(3);
});

console.log(total.get()); // 600
```

## When to Use batch

### Updating Related State

```ts
interface User {
  firstName: string;
  lastName: string;
  email: string;
}

const firstName = Signal("");
const lastName = Signal("");
const email = Signal("");

function updateUser(user: User) {
  batch(() => {
    firstName.set(user.firstName);
    lastName.set(user.lastName);
    email.set(user.email);
  });
}
```

### Form Resets

```ts
const name = Signal("");
const email = Signal("");
const message = Signal("");
const errors = Signal<string[]>([]);

function resetForm() {
  batch(() => {
    name.set("");
    email.set("");
    message.set("");
    errors.set([]);
  });
}
```

### State Machines

```ts
type Status = "idle" | "loading" | "success" | "error";

const status = Signal<Status>("idle");
const data = Signal<Data | null>(null);
const error = Signal<Error | null>(null);

async function fetchData() {
  batch(() => {
    status.set("loading");
    data.set(null);
    error.set(null);
  });

  try {
    const result = await api.getData();
    batch(() => {
      status.set("success");
      data.set(result);
    });
  } catch (e) {
    batch(() => {
      status.set("error");
      error.set(e as Error);
    });
  }
}
```

## Performance Considerations

Batch is useful when:

1. **Multiple signals update together** - Prevents intermediate states from triggering effects
2. **Updates are logically related** - Keeps state consistent
3. **Performance is critical** - Reduces the number of effect executions

Batch is NOT necessary when:

1. Updating a single signal
2. Updates are independent and don't need to be atomic
3. You want intermediate states to be observable

## See Also

- [Signals](/docs/concepts/signals)
- [Effects](/docs/concepts/effects)
- [effect()](/docs/api/effect)
