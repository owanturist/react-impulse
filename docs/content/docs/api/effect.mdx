---
title: effect
description: API reference for the effect function
---

# effect

The `effect` function creates a reactive effect that runs whenever its signal dependencies change.

## Function Signature

```ts
function effect(listener: (monitor: Monitor) => Destructor): VoidFunction

type Destructor = void | (() => void)
```

## Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `listener` | `(monitor: Monitor) => Destructor` | Effect function that receives a Monitor and may return a cleanup callback |

## Returns

Returns a `VoidFunction` that stops the effect when called.

## Examples

### Basic Effect

```ts
import { Signal, effect } from "@owanturist/signal"

const count = Signal(0)

effect((monitor) => {
  console.log(`Count: ${count.read(monitor)}`)
})
// Immediately logs: "Count: 0"

count.write(1)
// Logs: "Count: 1"
```

### Stopping an Effect

```ts
const count = Signal(0)

const stop = effect((monitor) => {
  console.log(count.read(monitor))
})
// Logs: 0

count.write(1)
// Logs: 1

stop() // Dispose the effect

count.write(2)
// Nothing logged
```

### Effect with Cleanup

The effect function can return a cleanup callback:

```ts
import { Signal, effect } from "@owanturist/signal"

const interval = Signal(1000)

effect((monitor) => {
  const ms = interval.read(monitor)
  const id = setInterval(() => {
    console.log("tick")
  }, ms)

  // Cleanup runs before re-execution and on disposal
  return () => {
    clearInterval(id)
  }
})

// Change interval - old interval is cleared, new one started
interval.write(500)
```

### DOM Event Listeners

```ts
const handler = Signal((e: MouseEvent) => {
  console.log("clicked", e.clientX, e.clientY)
})

effect((monitor) => {
  const fn = handler.read(monitor)
  document.addEventListener("click", fn)

  return () => {
    document.removeEventListener("click", fn)
  }
})
```

### Subscriptions

```ts
const userId = Signal("user-123")

effect((monitor) => {
  const id = userId.read(monitor)
  const unsubscribe = database.subscribe(`users/${id}`, (user) => {
    console.log("User updated:", user)
  })

  return unsubscribe
})
```

## Dependency Tracking

Effects automatically track signal dependencies through the Monitor:

```ts
const a = Signal(1)
const b = Signal(2)
const useA = Signal(true)

effect((monitor) => {
  if (useA.read(monitor)) {
    console.log("A:", a.read(monitor))
  } else {
    console.log("B:", b.read(monitor))
  }
})
// Logs: "A: 1"

b.write(10)
// Nothing logged (b is not a current dependency)

useA.write(false)
// Logs: "B: 10"

a.write(100)
// Nothing logged (a is no longer a dependency)
```

## Timing

Effects run synchronously after signal updates:

```ts
const count = Signal(0)

effect((monitor) => {
  console.log("effect:", count.read(monitor))
})
// Logs: "effect: 0"

console.log("before write")
count.write(1)
console.log("after write")

// Output order:
// "effect: 0"
// "before write"
// "effect: 1"
// "after write"
```

## Conditional Effects

Effects only run when their tracked dependencies change:

```ts
const enabled = Signal(false)
const count = Signal(0)

effect((monitor) => {
  if (!enabled.read(monitor)) {
    return // Early return - count is not tracked
  }
  console.log("Count:", count.read(monitor))
})

count.write(1) // No log (enabled is false, count not tracked)

enabled.write(true)
// Logs: "Count: 1"

count.write(2)
// Logs: "Count: 2"
```

## Cleanup Timing

The cleanup function runs:

1. **Before re-execution** - When dependencies change
2. **On disposal** - When `stop()` is called

```ts
const source = Signal("initial")

const stop = effect((monitor) => {
  const value = source.read(monitor)
  console.log("setup:", value)

  return () => {
    console.log("cleanup:", value)
  }
})
// Logs: "setup: initial"

source.write("updated")
// Logs: "cleanup: initial"
// Logs: "setup: updated"

stop()
// Logs: "cleanup: updated"
```

## Error Handling

If an effect throws, it won't prevent other effects from running:

```ts
const count = Signal(0)

effect((monitor) => {
  if (count.read(monitor) === 1) {
    throw new Error("Oops!")
  }
  console.log("effect 1:", count.read(monitor))
})

effect((monitor) => {
  console.log("effect 2:", count.read(monitor))
})

count.write(1)
// effect 1 throws
// effect 2 still logs: "effect 2: 1"
```

## Best Practices

### Single Responsibility

Each effect should do one thing:

```ts
// Good
effect((monitor) => {
  document.title = `Count: ${count.read(monitor)}`
})

effect((monitor) => {
  localStorage.setItem("count", String(count.read(monitor)))
})

// Less ideal
effect((monitor) => {
  const value = count.read(monitor)
  document.title = `Count: ${value}`
  localStorage.setItem("count", String(value))
})
```

### Always Clean Up Resources

```ts
effect((monitor) => {
  const ws = new WebSocket(url.read(monitor))

  ws.onmessage = (e) => {
    handleMessage(e.data)
  }

  return () => {
    ws.close()
  }
})
```

### Avoid Circular Dependencies

```ts
// BAD: Creates infinite loop
const count = Signal(0)
effect((monitor) => {
  count.write(count.read(monitor) + 1)
})

// GOOD: Use separate signals
const source = Signal(0)
const derived = Signal(0)
effect((monitor) => {
  derived.write(source.read(monitor) + 1)
})
```

## See Also

- [Effects Concept](/docs/concepts/effects)
- [batch()](/docs/api/batch)
- [untracked()](/docs/api/untracked)
