---
title: Impulse
description: Interface and Factory to create Impulse instances
---

## Overview [toc] [#overview]

<p id="overview" className="-mb-5 scroll-mt-100" />

`Impulse` is a reactive value container that stores and tracks changes to data.

```ts
import { Impulse } from "react-impulse"

interface State {
  query: Impulse<string>
}

const state: State = {
  query: Impulse("What is Declaration Merging?"),
}
```

<Callout>
  Thanks to TypeScript's [Declaration
  Merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html),
  both the `Impulse` interface and the factory function share the same name.
</Callout>

---

## `interface Impulse{:dart}` [toc] [#impulse-interface]

## `interface Impulse<T>{:dart}` [!toc] [#impulse-interface]

<section className="typedef">

- `@template T{:dart}` The type of value stored in the `Impulse`.

</section>

### `getValue(scope){:dart}` [toc] [#impulse-get-value]

### `getValue(scope: Scope): T{:dart}` [!toc] [#impulse-get-value]

The method retrieves the current value of the `Impulse`.

The impulse binds to the provided `Scope` during the read,
so that the next time the value changes, the `Scope` notifies the hosting environment about the update.

<section className="typedef">

- `@param scope: Scope{:dart}` The [`Scope{:ts}`](/docs/reference/scope) for binding to impulse updates.

---

- `@returns T{:dart}` The current value from the `Impulse`.

</section>

```ts tab="subscribe()"
import { Impulse, subscribe } from "react-impulse"

const counter = Impulse(0)

/**
 * Logs every time when counter changes.
 */
const unsubscribe = subscribe((scope) => {
  const count = counter.getValue(scope) // [!code highlight]

  console.log("Count updated: ", count)
})
```

```tsx tab="useScoped()"
import { type Impulse, useScoped } from "react-impulse"

/**
 * Re-renders every time when diff between bears and bulls changes.
 */
const Market = ({
  bears,
  bulls,
}: {
  bears: Impulse<number>
  bulls: Impulse<number>
}) => {
  const diff = useScoped(
    (scope) => bears.getValue(scope) - bulls.getValue(scope), // [!code highlight]
  )

  return <div>Diff: {diff}</div>
}
```

```tsx tab="batch()"
import { type Impulse, batch, useScoped } from "react-impulse"

const numerator = Impulse(10)
const denominator = Impulse(1)

/**
 * Re-renders every time when numerator or denominator change.
 */
const Fraction = () => {
  const scope = useScope()
  const fraction = numerator.getValue(scope) - denominator.getValue(scope) // [!code highlight]

  return <div>Fraction: {fraction}</div>
}

/**
 * Re-renders are never caused by numerator or denominator changes.
 */
const Tick = () => (
  <button
    onClick={() => {
      batch((scope) => {
        // [!code highlight:2]
        numerator.setValue(numerator.getValue(scope) - 1)
        denominator.setValue(denominator.getValue(scope) + 1)
      })
    }}
  >
    Next
  </button>
)
```

<Callout title="Good to know">

- A single `Impulse` can bind to multiple different `Scope`s independently.
- Multiple reads with the same `Scope` bind only once.
- Use a [non-tracking `Scope`](/docs/reference/scope#TODO-non-tracking) to avoid binding.

</Callout>

### `setValue(value){:ts}` [#impulse-set-value]

Updates the impulse with a new value. Consumers are notified only if the new value differs according to the compare function.

- `value: T{:ts}` - The new value to set.

### `setValue(transform){:ts}` [#impulse-set-value-transform]

Updates the impulse using a transform function that receives the current value.

- `transform: (currentValue: T, scope: Scope) => T{:ts}` - Function that transforms the current value. The scope is non-tracking.

### `clone(options?){:ts}` [#impulse-clone]

Creates an independent copy of the impulse with the same value but separate identity and dependencies.

- `options?: ImpulseOptions<T>{:ts}` - Configuration for the cloned impulse. Inherits the original's compare function if not specified.

Returns a new `Impulse<T>` instance.

### `clone(transform, options?){:ts}` [#impulse-clone-transform]

Creates an independent copy of the impulse with a transformed value.

- `transform: (value: T, scope: Scope) => T{:ts}` - Function to transform the value during cloning. The scope is non-tracking.
- `options?: ImpulseOptions<T>{:ts}` - Configuration for the cloned impulse.

Returns a new `Impulse<T>` instance with the transformed value.

---

## `Impulse(initialValue, options?){:dart}` [#impulse-factory]

```ts
function Impulse<T>(initialValue: T, options?: ImpulseOptions<T>): Impulse<T>
```

The factory function creates a new `Impulse<T>{:ts}` with the provided initial value.

<section className="typedef">

- `@param initialValue: T{:dart}` The starting value for the `Impulse`. Immutable values and other `Impulse`s work seamlessly.

  ```ts twoslash tab="Primitive"
  import { Impulse } from "react-impulse"

  // ---cut---
  const count = Impulse(0)
  //    ^?
  ```

  ```ts twoslash tab="Object"
  import { Impulse } from "react-impulse"

  // ---cut---
  const user = Impulse({ id: 1, name: "Alice" })
  //    ^?
  ```

  ```ts twoslash tab="Function"
  import { Impulse } from "react-impulse"
  // ---cut---
  const transformer = Impulse({ fn: (input: string) => input.trim() })
  //    ^?
  ```

  ```ts twoslash tab="Nested Impulses"
  import { Impulse } from "react-impulse"

  // ---cut---
  const cart = Impulse([
    //  ^?
    { slug: "cake", price: 39.99, amount: Impulse(1) },
    { slug: "candle", price: 0.19, amount: Impulse(12) },
  ])
  ```

  <Callout>
    Functions as `initialValue` create [Derived Impulses](/TODO). Store
    functions as values by wrapping them in an object.
  </Callout>

  <Callout type="warn">
    Mutable values might be used but be aware of [implications in React](/TODO).
  </Callout>

- `@param options?: ImpulseOptions<T>{:dart}` Configuration options for the `Impulse`.
- `@param options?.compare?: null | Compare{:dart}` The [`Compare<T>{:ts}`](/docs/reference/compare) function determines when the `Impulse` considers values equal.
  When not provided or set to `null{:ts}`, it defaults to `Object.is{:ts}`.

  ```ts tab="Default compare"
  const updatedAt = Impulse(new Date(1922, 11, 30))

  updatedAt.setValue(new Date(1991, 11, 26)) // ðŸ“¬ new value - notify consumers
  updatedAt.setValue(new Date(1991, 11, 26)) // ðŸ“¬ new (but similar) value - notify consumers
  ```

  ```ts tab="Custom compare"
  const updatedAt = Impulse(new Date(1922, 11, 30), {
    compare: (left, right) => left.getTime() === right.getTime(), // [!code ++]
  })

  updatedAt.setValue(new Date(1991, 11, 26)) // ðŸ“¬ new value - notify consumers
  updatedAt.setValue(new Date(1991, 11, 26)) // ðŸ“­ same value - do not notify consumers // [!code highlight]
  ```

---

- `@returns Impulse<T>{:dart}` A new `Impulse` instance containing the initial value.

</section>

---

## `Impulse(){:dart}` [#impulse-factory-optional]

```ts
function Impulse<T>(): Impulse<undefined | T>
```

The factory function creates a new `Impulse<undefined | T>{:ts}` with an initial value of `undefined{:ts}`.

<section className="typedef">

- `@returns Impulse<undefined | T>{:dart}` A new `Impulse` with an initial value of `undefined{:ts}`.

</section>

```ts twoslash
import { Impulse } from "react-impulse"

// ---cut---
const value = Impulse<number>()
//    ^?
```

<Callout>
  This is a shortcut for `Impulse<undefinedÂ |Â T>(undefined){:ts}`.
</Callout>
