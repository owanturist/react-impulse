# Knowledgebase → Docs → MCP: Implementation Plan

This plan bootstraps a single source of truth (the knowledgebase) that powers:

1. AI-assisted development (features, bugfixes, tests)
2. Autogenerated documentation following Diátaxis
3. An MCP server so users can plug the libraries’ expertise into their AI tools

## Checklist of requirements

- Create and maintain a knowledgebase (KB) for AI to implement features, fixes, and tests.
- Derive human-facing documentation from the KB using the [Diátaxis][diataxis] framework.
- Use [Astro][astro] for the docs site; allow interactive [React][react] “islands” (see [Astro Islands Architecture][astro-islands]).
- Provide versioned docs per package using branch-based semver ranges (no copies), e.g., `/react-impulse/1.x.x` or `/react-impulse/1.1.x`; latest remains the default route.
- Integrate with [Changesets][changesets] and existing release flows.
- Expose the KB via [MCP][mcp] so users can connect their AI agents to it.
- Define and automate a KB-first workflow (see “KB-first end-to-end workflow”).
- Continuously deploy the docs site on any docs/KB source change (not only on version bumps).

Status: this document specifies how each item will be implemented, with concrete, staged deliverables.

## TL;DR architecture

- KB is the source of truth: curated, structured Markdown with strict frontmatter.
- AI agents read KB → implement code/tests → update KB if needed.
- A generator transforms KB → [Diátaxis][diataxis] docs (Markdown/[MDX][mdx]) → [Astro][astro] site.
- [GitHub Actions][gha] validate KB, generate docs previews, and publish on release.
- An MCP server exposes KB search/get/tasks to AI clients.

## Agent quickstart (for Copilot/VS Code)

This is the minimal flow the agent will follow once Phase 1 scaffolding exists:

- Create or update a KB entry under `knowledgebase/entries/**` using a template (see below).
- Run kb lint (script to be added in Phase 1) to validate frontmatter and required sections.
- Implement code and tests to satisfy the KB acceptance-criteria and test-plan.
- (When available) Generate docs from the KB; don’t hand-edit generated files.
- Open a PR referencing the KB entry `id`; CI will lint KB and build docs.

Tip for prompts: “Implement according to KB entry `<entry-id>`; ensure tests cover all `acceptance-criteria` and listed edge cases; do not change public API without updating `api-changes` and `migration`.”

## Notes on MCP (what it enables here)

In brief, [Model Context Protocol (MCP)][mcp] lets tools expose resources and actions to AI clients. A small MCP server will:

- Serves KB entries as searchable resources (features, bugfixes, concepts, ADRs).
- Exposes “implementation briefs” as actionable tasks the agent can pick up.
- Returns structured JSON + raw Markdown so agents can render, reason, and execute.

Users connect their MCP-capable clients to this server and get first-class, up-to-date guidance on using and extending these libraries.

## Content model (KB schema)

Each KB entry is a Markdown file with YAML frontmatter enforcing:

- `id`: unique slug
- `title`: human-friendly title
- `type`: feature | bugfix | concept | decision | test-spec | doc-snippet
- `packages`: `[react-impulse, react-impulse-form]` (one or both)
- `status`: proposed | accepted | implemented | deprecated
- `versions`: optional semver range or array (e.g., `">=1.3.0"` or `["2.0.0"]`)
- `owner`: GitHub handle
- `last-reviewed`: `YYYY-MM-DD`
- `tags`: `[strings]`
- `relates-to`: `[entry-id, …]` links to related entries; required for `type`: `test-spec` (min 1)
- `diataxis`: reference | how-to | tutorial | explanation (primary landing doc target)
- `acceptance-criteria`: list
- `api-changes`: summary of public API deltas (if any)
- `migration`: guidance (if API changes)
- `test-plan`: brief + links to test-spec entries
- `references`: links to PRs, issues, external resources

Body content regions (headings) to standardize:

- Context and goals
- Design and rationale
- API contract (inputs/outputs, error modes, examples)
- Implementation notes (edge cases, perf, concurrency)
- Test scenarios (happy path + edge cases)
- Documentation notes (callouts, diagrams, interactive ideas)

These will be linted with a Zod schema ([Zod][zod]) and simple textual checks in CI. Frontmatter keys use kebab-case. For `type`: `test-spec`, `relates-to` must include at least one existing entry `id`.

## Folder structure

In this repo:

- knowledgebase/
  - PLAN.md (this file)
  - README.md (how to contribute, quickstart)
  - schema/ (Zod schema and lint rules)
  - entries/
    - features/…
    - bugfixes/…
    - concepts/…
    - decisions/ (ADRs)
    - test-specs/…
    - doc-snippets/…
  - templates/
    - feature.md
    - bugfix.md
    - decision.md
    - test-spec.md
    - doc-snippet.md
    - implementation-brief.md

Generator and tooling:

- packages/knowledgebase-tools/ (new package) — parsers, schema checks, doc generator
- packages/knowledgebase-mcp/ (new package) — MCP server exposing KB
- docs/ (Astro site; uses generated Diátaxis content)

## KB-first end-to-end workflow

1. Ideate a new feature, bugfix, or docs adjustment.
2. Update the knowledgebase (KB) first: add or revise an entry with context, acceptance-criteria, and test-plan. Commit.
3. Ask the AI agent to implement based on the KB: update code and add/adjust tests. Commit.
4. Review the changes. If the implementation diverges from the intended design, refine the KB (not the code) to clarify requirements. Commit.
5. Iterate steps 3–4 until the implementation satisfies the KB acceptance-criteria and test-plan.
6. Ask the AI agent to generate/update documentation from the KB (Markdown/MDX or templates). Commit.
7. Review docs. If they don’t reflect the idea well, refine the KB documentation notes while keeping code/tests unchanged; ensure KB stays compatible with the current implementation. Commit.
8. Iterate steps 6–7 until the docs match the intended outcome. Commit.
9. Ask the AI agent to compose a Changeset for the updated packages.
10. Review and adjust the Changeset if necessary. Commit.
11. Push the branch, open a PR, and request review. Use CI previews to validate docs and tests. If feedback requires changes, refine the KB and repeat steps 2–10.
12. Merge the PR once it passes review and all CI checks.
13. Release and docs:

- Changesets opens a release PR; on merge, versions are bumped and packages are published to npm.
- Documentation for released versions is served from maintenance branches; “latest” remains the default. See Versioned docs and CI/CD sections.
- Docs also deploy continuously on merges that touch docs/ or regenerate from KB, independent of releases.

## Diátaxis documentation pipeline

1. KB entry → normalized AST → [Diátaxis][diataxis] slice(s)
   - A single KB entry can produce multiple doc artifacts, e.g., a reference page and a how-to. Body sections are mapped to target doc templates.

2. Generator writes Markdown/[MDX][mdx] into docs/ following Diátaxis structure:
   - docs/react-impulse/{reference,how-to,explanation,tutorials}/…
   - docs/react-impulse-form/{…}/…

3. Interactive islands: add MDX directives where notes call for interactivity. [Astro][astro] renders [React][react] islands at those anchors (see [Astro Islands Architecture][astro-islands]).

Versioned docs (branch-based, no snapshots):

- Documentation versions are represented by protected branches that correspond to maintenance ranges (e.g., `1.x.x` ⇒ `>=1.0.0 <2.0.0`; `1.1.x` ⇒ `>=1.1.0 <1.2.0`).
- Each branch builds the docs site once and deploys routes for all packages present in the branch based on the version in each package’s package.json:
  - `/react-impulse/1.x.x` or `/react-impulse/1.1.x`
  - `/react-impulse-form/2.x.x` or `/react-impulse-form/2.0.x`
- The default branch deploys the latest routes:
  - `/react-impulse` (latest)
  - `/react-impulse-form` (latest)
- No copy/paste or freezing of content into per-version directories; the branch is the version. A change merged into a maintenance branch updates the corresponding versioned docs route(s).

## AI agent guardrails

- Never change public API without updating api-changes + migration in KB.
- Tests must cover acceptance-criteria and edge cases listed in KB.

## CI/CD

PR validation:

- Lint KB frontmatter against schema (type, packages, status, etc.)
- Check for mandatory body sections based on type
- Use Zod error formatting (e.g., `z.prettifyError`) for readable diagnostics in CI logs
- Build docs generator (dry run) and ensure no broken links
- Build [Astro][astro] site (preview) and upload artifact / deploy preview

Release:

- After [Changesets][changesets] releases packages, a job can validate that maintenance branches reflect the intended version ranges (optional guardrails).
- [Astro][astro] build → deploy to owanturist.me; default branch updates `latest` routes.

Docs deployment (per-branch, independent of package releases):

- On merge to the default branch, if changes touch any of:
  - docs/\*\* (site sources, themes, MDX, components)
  - knowledgebase/\*\* (content that regenerates docs)
  - packages/knowledgebase-tools/\*\* (generator affecting output)
  - packages/knowledgebase-mcp/docs/\*\* (if MCP usage docs are hosted within the site)
- Then: run generator → build with [Astro][astro] → deploy `latest` routes
- This redeploys the latest docs without creating a new package version.

- On merge to a maintenance branch (e.g., `1.x.x` or `1.1.x`):
  - Determine each package’s semver from packages/\*/package.json.
  - Compute the branch label (e.g., `1.x.x` or `1.1.x`) and verify versions fall within the branch’s declared range; fail CI if not.
  - Build with [Astro][astro] and deploy under branch-based routes per package, e.g.,
  - `/react-impulse/1.x.x` or `/react-impulse/1.1.x`
  - `/react-impulse-form/2.x.x` or `/react-impulse-form/2.0.x`
  - Keep the header “version switcher” compatible across branches by reading a shared versions manifest (see below).

Versions manifest for switcher:

- Publish a small JSON manifest alongside each deployment (e.g., /versions.json) listing known branches and labels for all packages.
- Optionally, maintain a central manifest in the deployment branch (e.g., `gh-pages`) that is updated by each branch’s deployment job to aggregate all versions.

## MCP server (packages/knowledgebase-mcp)

- kb.entry (by id)
- kb.search (by type, packages, tags, status, text)
- kb.tasks (list of implementation-briefs)
- tools:
  - kb.get(id)
  - kb.search(query)
  - kb.brief.pick(id) → returns a structured brief the agent can execute

Implementation:

- [Node.js][node] + [TypeScript][typescript]; read-only FS access to knowledgebase/entries
- Parse frontmatter; expose JSON + Markdown body
- Provide small, stable JSON contracts the agent can rely on
- Publish as a package for easy local install or dockerized use

Client setup:

- Document how to add this MCP server to common AI tools (desktop clients, editors). Provide sample config snippets in docs.

## Concrete deliverables and phases

Phase 0 — Bootstrap

- [x] knowledgebase/ folder with PLAN.md and README.md
- [x] Agree on KB schema fields and templates (tracked below)

Phase 1 — KB structure and validation

- [x] Add schema/ with Zod frontmatter schema
- [x] Add templates/ (feature, bugfix, decision, test-spec, doc-snippet, implementation-brief)
- [ ] Add a couple of seed entries for existing, stable APIs
- [x] CI job: schema lint + minimal content checks

Definition of Done (Phase 1):

- `knowledgebase/schema/frontmatter-schema.mjs` exists and validates required fields and types (Zod). The KB linter imports and uses it.
- `knowledgebase/templates/*` provides authoring scaffolds (feature, bugfix, decision, test-spec, doc-snippet, implementation-brief).
- `knowledgebase/entries/*` contains at least two seed entries with valid frontmatter and required sections.
- A repository script is available to run lint locally (e.g., `pnpm kb:lint`).

Phase 2 — Doc generator + Astro site

- [ ] Create packages/knowledgebase-tools: parser + generator (KB → Diátaxis MD/MDX)
- [ ] Create docs/ Astro site ([Starlight][starlight] recommended for structure + MDX + islands)
- [ ] Wire generator output into docs/
- [ ] CI: build and preview docs on PRs

Definition of Done (Phase 2):

- A generator converts KB entries into Diátaxis-aligned MD/MDX under `docs/`.
- Astro site builds locally and in CI; broken links and missing pages fail the build.
- At least one interactive island example is rendered via MDX for a documented API.

Phase 3 — Versioned docs (branch-based) + release integration

- [ ] Establish protected maintenance branches (e.g., `1.x.x`, `1.1.x`) per package stream policy
- [ ] CI: deploy default branch to `latest` routes per package
- [ ] CI: deploy maintenance branches to branch-based routes (e.g., `/<pkg>/1.x.x` or `/<pkg>/1.1.x`)
- [ ] CI: validate branch range vs package.json versions (guardrail)
- [ ] CI: continuously deploy docs on merges affecting docs/**, knowledgebase/**, or generator sources

Definition of Done (Phase 3):

- Protected maintenance branches established per package stream policy.
- Default branch deploys `latest`; maintenance branches deploy under branch-based routes.
- CI guardrails validate branch version ranges against package.json versions.

Phase 4 — MCP server

- [ ] Create packages/knowledgebase-mcp with search/get/tools endpoints
- [ ] Docs for configuring clients
- [ ] Optional: small web UI to browse KB (could be part of docs site)

Definition of Done (Phase 4):

- `packages/knowledgebase-mcp` exposes kb.get, kb.search, kb.brief.pick per the JSON contracts.
- Read-only FS access to `knowledgebase/entries` with frontmatter parsing.
- Minimal client configuration examples included in docs.

Phase 5 — Routines and prompts

- [ ] Add authoring guide (knowledgebase/README.md) and prompts for AI agents
- [ ] Add PR checklist: “KB updated?”, “Docs generated?”, “Changeset created?”

Definition of Done (Phase 5):

- Authoring guide with standard prompts and anti-patterns.
- CONTRIBUTING/PR template enforces KB-first workflow and changeset presence.

## Conventions and success criteria

- Every user-visible change must have a KB entry (feature/bugfix/decision) with acceptance-criteria and test-plan.
- No API change without api-changes + migration.
- Docs are always generated from KB; never hand-edit generated files.
- MCP stays in sync by reading the KB at runtime (or on build, if caching is used).

## Collaboration model (curator + AI)

- The curator maintains KB entries; the AI agent implements code and tests and regenerates docs.
- Ambiguities are flagged early; propose KB edits before coding to resolve them.
- CI remains green (schema lint, build, tests) via iterative fixes until passing.

[diataxis]: https://diataxis.fr/
[astro]: https://astro.build/
[starlight]: https://starlight.astro.build/
[astro-islands]: https://docs.astro.build/en/concepts/islands/
[changesets]: https://github.com/changesets/changesets
[mcp]: https://modelcontextprotocol.io/
[mdx]: https://mdxjs.com/
[gha]: https://docs.github.com/en/actions
[node]: https://nodejs.org/
[typescript]: https://www.typescriptlang.org/
[zod]: https://zod.dev/
[react]: https://react.dev/
